<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: iOS | 山芋头</title>
  <meta name="description" content="记录和总结让知识得到积累，分享能创造价值" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/bianchengme/">
  <link rel="alternate" href="/bianchengme/atom.xml" title="山芋头">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录和总结让知识得到积累，分享能创造价值">
<meta property="og:type" content="website">
<meta property="og:title" content="山芋头">
<meta property="og:url" content="https://bianchengme.gitee.io/bianchengme/tags/iOS/page/2/index.html">
<meta property="og:site_name" content="山芋头">
<meta property="og:description" content="记录和总结让知识得到积累，分享能创造价值">
<meta property="og:locale" content="cn">
<meta property="article:author" content="jmme@foxmail.com">
<meta name="twitter:card" content="summary">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  
<link rel="stylesheet" href="/bianchengme/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/bianchengme/atom.xml" title="山芋头" type="application/atom+xml">
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/bianchengme/' >
				山芋头
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/bianchengme/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/bianchengme/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN' target="_blank" rel="noopener">
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/bianchengme/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/bianchengme/" class="nav-home nav">
				Home
			</a>
		
			<a href="/bianchengme/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN" target="_blank" rel="noopener" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/bianchengme/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : iOS'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91UI%E6%80%BB%E7%BB%93/">
        iOS开发UI总结
      </a>
    </h2>
    
    <time>
      Mar 29, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  <h1 id="UI相关的几个要点"><a href="#UI相关的几个要点" class="headerlink" title="UI相关的几个要点"></a>UI相关的几个要点</h1><ul>
<li>UIView &amp; CALayer</li>
<li>事件传递和视图响应链</li>
<li>图像显示原理</li>
<li>UI卡顿掉帧原理</li>
<li>滑动优化方案</li>
<li>离屏渲染</li>
</ul>
<h2 id="UIView-amp-CALayer"><a href="#UIView-amp-CALayer" class="headerlink" title="UIView &amp; CALayer"></a>UIView &amp; CALayer</h2><p>UIView不用介绍，CALayer类在概念上和UIView类似，每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews。但是 Layer 比 View 多了个AnchorPoint。UIView可以通过CALayer可以实现 <strong>阴影，圆角，带颜色的边框、3D变换、非矩形规范、透明遮照、多级非线性动画</strong>等。</p>
<p>他们的区别是：</p>
<ul>
<li>与UIView最大的不同就是CALyer不处理用户的交互,不清楚具体的响应链；</li>
<li>二者并无继承关系，CALyer是UIView显示内容的内部实现；</li>
<li>UIView是对CALayer的一个封装，并提供了一些显示控制和响应链的功能；</li>
</ul>
<p>这样的设计体现了单一职责原则：UIView为CALayer提供内容，以及负责处理触摸等事件，参与响应链；CALayer负责显示内容contents。</p>
<p>##事件传递 &amp; 视图响应链</p>
<p>两个UIView方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空间是否响事件测试</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;判断点位位置是否在区域内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>

<p>事件传递顺序</p>
<p><img src="02event.png" alt="png"></p>
<p>通过代码体现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此方法就是寻找最为合适的响应的控件</span><br><span class="line">   override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">    </span><br><span class="line">       super.hitTest(point, with: event);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 1 UIView不接收触摸事件的三种情况：       </span><br><span class="line">       if self.isUserInteractionEnabled &#x3D;&#x3D; false || self.alpha &lt;&#x3D; 0.1 || self.isHidden &#x3D;&#x3D; true &#123;</span><br><span class="line">           return nil;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F;  2 判断当前的点是否在此控件上面</span><br><span class="line">       if self.point(inside: point, with: event) &#x3D;&#x3D; false &#123;</span><br><span class="line">           return nil;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 3 以上条件都满足 去遍历自己的子空间</span><br><span class="line">       for view in self.subviews &#123;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 转为目标控件的点</span><br><span class="line">           let current_point &#x3D; self.convert(point, to: view);</span><br><span class="line">           &#x2F;&#x2F; 让子视图再去遍历 如果有的话 进行返回操作 没有的话 不要紧 返回nil就好了</span><br><span class="line">           if view.hitTest(current_point, with: event) !&#x3D; nil &#123;</span><br><span class="line">               return view;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 4 如果以上都没有找到 那就返回自己</span><br><span class="line">       return self;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用逻辑<br><img src="03action.png" alt="png"></p>
<h2 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h2><p>cpu和GPU关系<br><img src="04cpu.png" alt="png"></p>
<p>1.CPU:输出位图<br>2.GPU :图层渲染，纹理合成<br>3.把结果放到帧缓冲区(frame buffer)中<br>4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容<br>5.显示到屏幕上</p>
<p>cpu和gpu的显示中的分工<br><img src="05gpu.png" alt="png"></p>
<p>CPU工作<br>1.Layout: UI布局，文本计算<br>2.Display: 绘制<br>3.Prepare: 图片解码<br>4.Commit：提交位图</p>
<p>GPU渲染管线(OpenGL)<br>顶点着色，图元装配，光栅化，片段着色，片段处理</p>
<p>##UI卡顿掉帧的原因<br><img src="06kadun.png" alt="png"></p>
<p>iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。</p>
<p>一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。</p>
<p>##滑动优化方案<br>CPU：把以下操作放在子线程中<br>1.对象创建、调整、销毁<br>2.预排版（布局计算、文本计算、缓存高度等等）<br>3.预渲染（文本等异步绘制，图片解码等）</p>
<p>GPU:<br>纹理渲染，视图混合</p>
<p>一般遇到性能问题时，考虑以下问题：<br>是否受到CPU或者GPU的限制？<br>是否有不必要的CPU渲染？<br>是否有太多的离屏渲染操作？<br>是否有太多的图层混合操作？<br>是否有奇怪的图片格式或者尺寸？<br>是否涉及到昂贵的view或者效果？<br>view的层次结构是否合理？  </p>
<h2 id="UI绘制原理"><a href="#UI绘制原理" class="headerlink" title="UI绘制原理"></a>UI绘制原理</h2><p><img src="07display.png" alt="png"></p>
<p>异步绘制：<br><strong>[self.layer.delegate displayLayer: ]</strong><br>代理负责生成对应的bitmap,<br>设置该bitmap作为该layer.contents属性的值</p>
<p><img src="08yibuhuizhi.png" alt="png"></p>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>On-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行<br>Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作<br>应当尽量避免的则是GPU离屏渲染</p>
<p>GPU离屏渲染何时会触发呢？<br>圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.shouldRasterize ＝ YES</span><br></pre></td></tr></table></figure>

<p><em>为什么要避免GPU离屏渲染？</em></p>
<p>GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
        <a href="/bianchengme/tags/UI/">UI</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91%E4%B8%ADRunTime%E6%80%BB%E7%BB%93/">
        iOS开发中RunTime总结
      </a>
    </h2>
    
    <time>
      Mar 29, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  <p>#runtime相关</p>
<ul>
<li>数据结构：NSObject、objc_object、objc_class、isa、class_data_bits_t、cache_t、method_t</li>
<li>对象、类对象、元类对象</li>
<li>消息传递、消息转发</li>
</ul>
<h3 id="一、数据结构：NSObject、objc-object、objc-class、isa、class-data-bits-t、cache-t、method-t"><a href="#一、数据结构：NSObject、objc-object、objc-class、isa、class-data-bits-t、cache-t、method-t" class="headerlink" title="一、数据结构：NSObject、objc_object、objc_class、isa、class_data_bits_t、cache_t、method_t"></a>一、数据结构：NSObject、objc_object、objc_class、isa、class_data_bits_t、cache_t、method_t</h3><p><img src="object_struct.png" alt="img"></p>
<ul>
<li>NSObject<br>在OC中，基本上所有的类的基类，都是NSObject。因此要深入了解OC中的类的结构，就要从NSObject这个类说起。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject仅有一个实例变量Class isa：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<ul>
<li>Class实质上是指向objc_class的指针。而objc_class的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，objc_class继承自objc_object；在objc_class中，有三个数据成员：superclass 、cache、bits。</p>
<ul>
<li><p>Class superclass ：同样是Class类型，表明当前类的父类。</p>
</li>
<li><p>cache_t cache ：用于快速查找方法执行函数，可增量扩展的哈希表结构，是局部性原理的最佳运用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;&#x2F;&#x2F;一个散列表，用来方法缓存，bucket_t类型，包含key以及方法实现IMP</span><br><span class="line">    mask_t _mask;&#x2F;&#x2F;分配用来缓存bucket的总数</span><br><span class="line">    mask_t _occupied;&#x2F;&#x2F;表明目前实际占用的缓存bucket的个数</span><br><span class="line">｝</span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure>

<p>runtime当要调用一个方法时，先不去Class的方法列表中查找，而是先去找cache_t cache 。当系统调用过一个方法后，会将其实现IMP和key存放到cache中，因为理论上一个方法调用过后，被再次调用的概率很大。</p>
<ul>
<li>class_data_bits_t bits：这是Class的核心，其本质是一个可以被Mask的指针类型。根据不同的Mask，可以取出不同的值。可以看做对class_rw_t的封装。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"> </span><br><span class="line">    public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        &#x2F;&#x2F; Set during realization or construction only. No locking needed.</span><br><span class="line">        &#x2F;&#x2F; Use a store-release fence because there may be concurrent</span><br><span class="line">        &#x2F;&#x2F; readers of data and data&#39;s contents.</span><br><span class="line">        uintptr_t newBits &#x3D; (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;</span><br><span class="line">        atomic_thread_fence(memory_order_release);</span><br><span class="line">        bits &#x3D; newBits;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br></pre></td></tr></table></figure>

<p>class_data_bits_t bits 仅含有一个成员uintptr_t bits， 可以理解为一个‘复合指针’。什么意思呢，就是bits不仅包含了指针，同时包含了Class的各种异或flag，来说明Class的属性。把这些信息复合在一起，仅用一个uint指针bits来表示。当需要取出这些信息时，需要用对应的以FAST_ 前缀开头的flag掩码对bits做按位与操作。</p>
<p>例如，我们需要取出Classs的核心信息class_rw_t, 则需要调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>class_rw_t：Class的核心结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">     uint32_t flags;</span><br><span class="line">     uint32_t version;</span><br><span class="line"></span><br><span class="line">     const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">     method_array_t methods;</span><br><span class="line">     property_array_t properties;</span><br><span class="line">     protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">     Class firstSubclass;</span><br><span class="line">     Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">     char *demangledName;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>Objc的类的属性、方法、以及遵循的协议都放在class_rw_t中，class_rw_t代表了类相关的读写信息，是对class_ro_t的封装，而class_ro_t代表了类的只读信息，存储了 编译器决定了的属性、方法和遵守协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    #ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>objc_object（id）</li>
</ul>
<p>OC的底层实现是runtime，在runtime这一层，对象被定义为objc_object 结构体，类被定义为了objc_class 结构体。而objc_class 继承于objc_object， 因此，类可以看做是一类特殊的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略其余方法</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_object的定义很简单，仅包含一个isa_t类型 isa,有关于isa操作相关，弱引用相关，关联对象相关，内存关联相关。</p>
<ul>
<li>isa指针，共用体isa_t</li>
</ul>
<p>isa关于对象，其指向类对象。<br>关于类对象，其指向元类对象。<br>实例-(isa)-&gt;class-(isa)-&gt;MetaClass    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 省略其余</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="02isa.png" alt="img"></p>
<ul>
<li>method_t</li>
</ul>
<p>函数四要素：名称、返回值、参数、函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">  SEL name;           &#x2F;&#x2F;名称</span><br><span class="line">  const char *types;&#x2F;&#x2F;返回值和参数</span><br><span class="line">  IMP imp;              &#x2F;&#x2F;函数体</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h3 id="二、对象、类对象、元类对象"><a href="#二、对象、类对象、元类对象" class="headerlink" title="二、对象、类对象、元类对象"></a>二、对象、类对象、元类对象</h3><ul>
<li>类对象存储实例方法列表等信息；</li>
<li>元类对象存储类方法列表等信息；</li>
</ul>
<p><img src="03class.png" alt="img"></p>
<p>superClass是一层层集成的，到最后NSObject的superClass是nil。而NSObject的isa指向根元类，这个根元类的isa指向他自己，而他的superClass是NSObject，也就是最后形成一个环。</p>
<h3 id="三、消息传递"><a href="#三、消息传递" class="headerlink" title="三、消息传递"></a>三、消息传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(void &#x2F;* id self, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained _Nonnull Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>消息传递的流程：缓存查找–&gt;当前类查找–&gt;父类逐级查找</p>
<ul>
<li><p>调用方法之前，先去查找缓存，看看缓存中是否有对应选择器的方法实现，如果有，就去调用函数，完成消息传递（缓存查找：给定值SEL,目标是查找对应bucket_t中的IMP，哈希查找）</p>
</li>
<li><p>如果缓存中没有，会根据当前实例的isa指针查找当前类对象的方法列表，看看是否有同样名称的方法 ，如果找到，就去调用函数，完成消息传递（当前类中查找：对于已排序好的方法列表，采用二分查找，对于没有排序好的列表，采用一般遍历）</p>
</li>
<li><p>如果当前类对象的方法列表没有，就会逐级父类方法列表中查找，如果找到，就去调用函数，完成消息传递（父类逐级查找：先判断父类是否为nil，为nil则结束，否则就继续进行缓存查找–&gt;当前类查找–&gt;父类逐级查找的流程）</p>
</li>
<li><p>如果一直查到根类依然没有查找到，则进入到消息转发流程中，完成消息传递</p>
</li>
</ul>
<h3 id="四、消息转发"><a href="#四、消息转发" class="headerlink" title="四、消息转发"></a>四、消息转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;&#x2F;&#x2F;为对象方法进行决议</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel;&#x2F;&#x2F;为类方法进行决议</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;&#x2F;&#x2F;方法转发目标</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>
<p><img src="04message.png" alt="img"></p>
<p>那么最后消息未能处理的时候，还会调用到</p>
<ul>
<li><p>(void)doesNotRecognizeSelector:(SEL)aSelector这个方法，我们也可以在这个方法中做处理，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来</p>
</li>
<li><p>方法交换(Method-Swizzling)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  + (void)load</span><br><span class="line">&#123;</span><br><span class="line">    Method test &#x3D; class_getInstanceMethod(self, @selector(test));</span><br><span class="line"></span><br><span class="line">    Method otherTest &#x3D; class_getInstanceMethod(self, @selector(otherTest));</span><br><span class="line"></span><br><span class="line">    method_exchangeImplementations(test, otherTest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：替换系统的方法，比如viewDidLoad，viewWillAppear以及一些响应方法，来进行统计信息</p>
<ul>
<li>动态添加方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(self, sel, testImp, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">void testImp (void)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;testImp&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@dynamic 动态方法解析</li>
</ul>
<p>动态运行时语言将函数决议推迟到运行时<br>编译时语言在编译期进行函数决议</p>
<ul>
<li>[obj foo]和objc_msgSend()函数之间有什么关系？</li>
</ul>
<p>objc_msgSend()是[obj foo]的具体实现。在runtime中，objc_msgSend()是一个c函数，[obj foo]会被翻译成这样的形式objc_msgSend(obj, foo)。</p>
<ul>
<li>runtime是如何通过selector找到对应的IMP地址的？</li>
</ul>
<p>缓存查找–&gt;当前类查找–&gt;父类逐级查找</p>
<ul>
<li>能否向编译后的类中增加实例变量？</li>
</ul>
<p>不能。 编译后，该类已经完成了实例变量的布局，不能再增加实例变量。<br>但可以向动态添加的类中增加实例变量。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
        <a href="/bianchengme/tags/RunTime/">RunTime</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/">
        iOS开发中内存管理总结
      </a>
    </h2>
    
    <time>
      Mar 29, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/15/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
        iOS网络编程
      </a>
    </h2>
    
    <time>
      Mar 15, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  

    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
        <a href="/bianchengme/tags/%E7%BD%91%E7%BB%9C/">网络</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/05/iOS%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/">
        iOS常见算法汇总
      </a>
    </h2>
    
    <time>
      Mar 5, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  <h1 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h1><ul>
<li>字符串反转</li>
<li>链表反转</li>
<li>有序数组合并</li>
<li>Hash算法</li>
<li>查找两个子视图的共同父视图</li>
<li>求无序数组当中的中位数</li>
</ul>
<p><a href="https://github.com/shanyutou/ALGforC" target="_blank" rel="noopener">github地址</a></p>
<h2 id="1-字符串反转"><a href="#1-字符串反转" class="headerlink" title="1.字符串反转"></a>1.字符串反转</h2><p>给定字符串 “Hello,world”实现将其反转。输出“dlrow,olleh”。</p>
<p>思路：字符串数组中从开始收尾交换，一直到中间元素，实现数组反转；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"hello,world"</span>;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">begin</span> = ch;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">end</span> = ch + <span class="built_in">strlen</span>(ch) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> temp = *<span class="built_in">begin</span>;</span><br><span class="line">    *(<span class="built_in">begin</span>++) = *<span class="built_in">end</span>;</span><br><span class="line">    *(<span class="built_in">end</span>--) = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"reverseString:%s\n"</span>, ch);</span><br></pre></td></tr></table></figure>

<h2 id="2-链表反转"><a href="#2-链表反转" class="headerlink" title="2.链表反转"></a>2.链表反转</h2><p>反转前1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>反转后4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>思路：因为链表是从头到尾遍历，想要反转，最方便的就是构造链表从尾部到头部的顺序构造。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  定义一个链表  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    NSInteger data;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)listReverse</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">p</span> = [<span class="title">self</span> <span class="title">constructList</span>];</span></span><br><span class="line">    </span><br><span class="line">    [self printList:p];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反转后的链表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newH</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录下一个结点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">temp</span> = <span class="title">p</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        <span class="comment">//当前结点的next指向新链表的头部</span></span><br><span class="line">        p-&gt;next = newH;</span><br><span class="line">        <span class="comment">//更改新链表头部为当前结点</span></span><br><span class="line">        newH = p;</span><br><span class="line">        <span class="comment">//移动p到下一个结点</span></span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self printList:newH];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 打印链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param head 给定链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)printList:(struct Node *)head</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"list is : "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%zd "</span>,temp-&gt;data);</span><br><span class="line">        </span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  构造链表  */</span></span><br><span class="line">- (struct Node *)constructList</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">//尾结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">cur</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">        </span><br><span class="line">        node-&gt;data = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//头结点为空，新结点即为头结点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            head = node;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前结点的next为尾结点</span></span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置当前结点为新结点</span></span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-有序数组合并"><a href="#3-有序数组合并" class="headerlink" title="3.有序数组合并"></a>3.有序数组合并</h2><p>将有序数组 和 合并为</p>
<p>思路：两个数组一起遍历，选择合适的（比较小的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)orderListMerge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> aLen = <span class="number">5</span>,bLen = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    [self printList:a length:aLen];</span><br><span class="line">    </span><br><span class="line">    [self printList:b length:bLen];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">14</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>,i = <span class="number">0</span>;<span class="comment">//p和q分别为a和b的下标，i为合并结果数组的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任一数组没有达到s边界则进行遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; aLen &amp;&amp; q &lt; bLen) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果a数组对应位置的值小于b数组对应位置的值,则存储a数组的值，并移动a数组的下标与合并结果数组的下标</span></span><br><span class="line">        <span class="keyword">if</span> (a[p] &lt; b[q]) result[i++] = a[p++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//否则存储b数组的值，并移动b数组的下标与合并结果数组的下标</span></span><br><span class="line">        <span class="keyword">else</span> result[i++] = b[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果a数组有剩余，将a数组剩余部分拼接到合并结果数组的后面</span></span><br><span class="line">    <span class="keyword">while</span> (++p &lt; aLen) &#123;</span><br><span class="line">        </span><br><span class="line">        result[i++] = a[p];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果b数组有剩余，将b数组剩余部分拼接到合并结果数组的后面</span></span><br><span class="line">    <span class="keyword">while</span> (q &lt; bLen) &#123;</span><br><span class="line">        </span><br><span class="line">        result[i++] = b[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self printList:result length:aLen + bLen];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)printList:(<span class="keyword">int</span> [])<span class="built_in">list</span> length:(<span class="keyword">int</span>)length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-HASH算法"><a href="#4-HASH算法" class="headerlink" title="4.HASH算法"></a>4.HASH算法</h2><ul>
<li><p>哈希表</p>
</li>
<li><p>在一个字符串中找到第一个只出现一次的字符。如输入“fsfsbcd”,输出”b”;</p>
</li>
</ul>
<p>思路：字符（char）是一个长度为8的数据类型，因此总共有256中可能。每个字母根据其ASC||码值作为组数下标对应数组中的一个数字。数组中存储每次字符出现的次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hashTest</span><br><span class="line">&#123;</span><br><span class="line">    NSString * testString = @<span class="string">"hhaabccdeef"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> testCh[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(testCh, [testString cStringUsingEncoding:NSUTF8StringEncoding], [testString length]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">256</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">list</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = testCh;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> result = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*p != result) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">list</span>[*(p++)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = testCh;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*p != result) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[*p] == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            result = *p;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result:%c"</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-查找两个子视图的共同父视图"><a href="#5-查找两个子视图的共同父视图" class="headerlink" title="5.查找两个子视图的共同父视图"></a>5.查找两个子视图的共同父视图</h2><p>思路:分别记录两个子视图的所有父视图并保存到数组中，然后倒序寻找,直至找到第一个不一样的父视图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)findCommonSuperViews:(UIView *)view1 view2:(UIView *)view2</span><br><span class="line">&#123;</span><br><span class="line">    NSArray * superViews1 = [self findSuperViews:view1];</span><br><span class="line">    </span><br><span class="line">    NSArray * superViews2 = [self findSuperViews:view2];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * resultArray = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; MIN(superViews1.count, superViews2.count)) &#123;</span><br><span class="line">        </span><br><span class="line">        UIView *super1 = superViews1[superViews1.count - i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        UIView *super2 = superViews2[superViews2.count - i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (super1 == super2) &#123;</span><br><span class="line">            </span><br><span class="line">            [resultArray addObject:super1];</span><br><span class="line">            </span><br><span class="line">            i++;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"resultArray:%@"</span>,resultArray);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSArray &lt;UIView *&gt;*)findSuperViews:(UIView *)view</span><br><span class="line">&#123;</span><br><span class="line">    UIView * temp = view.superview;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * result = [NSMutableArray <span class="built_in">array</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        </span><br><span class="line">        [result addObject:temp];</span><br><span class="line">        </span><br><span class="line">        temp = temp.superview;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-求无序数组中的中位数"><a href="#6-求无序数组中的中位数" class="headerlink" title="6.求无序数组中的中位数"></a>6.求无序数组中的中位数</h2><p>中位数：当数组个数n为奇数时，为(n + 1)/2，即是最中间那个数字；当n为偶数时，为(n/2 + (n/2 + 1))/2,即是中间两个数字的平均数。</p>
<p>思路:</p>
<p>1.排序算法+中位数<br>首先用冒泡排序、快速排序、堆排序、希尔排序等排序算法将所给数组排序，然后取出其中位数即可。<br>2.利用快排思想</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
        <a href="/bianchengme/tags/%E7%AE%97%E6%B3%95/">算法</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/bianchengme/2019/03/01/UI-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0/">
        UI 为什么必须要在主线程更新
      </a>
    </h2>
    
    <time>
      Mar 1, 2019
    </time>
		
    
    <div class='cats'>
        <a href="/bianchengme/categories/iOS/">iOS</a>
    </div>

  </section>
  <section class="article typo">
	  <p>在iOS开发中，一直知道不能再子线程中更新UI，但是被面试官问到为什么不能再子线程中更新UI,却不知道了尴尬，这就是学习不探究原理的的毛病，要治。</p>
<p>UIKit 官方文档中有重点提示： </p>
<p><strong>Important</strong></p>
<p>Use UIKit classes only from your app’s main thread or main dispatch queue, unless otherwise indicated. This restriction particularly applies to classes derived from UIResponder or that involve manipulating your app’s user interface in any way.</p>
<p>意思就是只能在主线程或者主队列中使用UIKit类，特别适用于派生自UIPResponder的类，或者涉及到以任何方式操纵应用程序的用户界面。</p>
<p>我们探究背后的原因是什么？</p>
<p>UIKit并不是一个线程安全的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上同时更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</p>
<p><strong>UIKit非线程安全</strong></p>
<p>在UIKit中，很多类中大部分的属性都被修饰为nonatomic，这意味着它们不能在多线程的环境下工作，而对于UIKit这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将nonatomic改成atomic或者是加锁解锁的操作，还涉及到很多的方面：</p>
<p>假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？</p>
<p>假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。</p>
<p>如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？</p>
<p>仔细思考，似乎能够多线程处理UI并没有给我们开发带来更多的便利，假如你代入了这些情景进行思考，你很容易得出一个结论： “我在一个串行队列对这些事件进行处理就可以了。” 苹果也是这样想的，所以UIKit的所有操作都要放到主线程串行执行。</p>
<p>在Thread-Safe Class Design一文提到：</p>
<p>It’s a conscious design decision from Apple’s side to not have UIKit be thread-safe. Making it thread-safe wouldn’t buy you much in terms of performance; it would in fact make many things slower. And the fact that UIKit is tied to the main thread makes it very easy to write concurrent programs and use UIKit. All you have to do is make sure that calls into UIKit are always made on the main thread.</p>
<p>大意为把UIKit设计成线程安全并不会带来太多的便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。事实上并发编程也没有因为UIKit是线程不安全而变得困难，我们所需要做的只是要确保UI操作在主线程进行就可以了。</p>
<p><strong>Runloop 与绘图循环</strong></p>
<p>道理我们都懂，那这个究竟跟我们不能在后台线程操作UI有什么关系呢？</p>
<p>UIApplication在主线程所初始化的Runloop我们称为Main Runloop，它负责处理app存活期间的大部分事件，如用户交互等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够得到不断刷新也是因为Main Runloop在驱动着。</p>
<p>而每一个view的变化的修改并不是立刻变化，相反的会在当前run loop的结束的时候统一进行重绘，这样设计的目的是为了能够在一个runloop里面处理好所有需要变化的view，包括resize、hide、reposition等等，所有view的改变都能在同一时间生效，这样能够更高效的处理绘制，这个机制被称为<strong>绘图循环（View Drawing Cycle)</strong>。</p>
<h2 id="理解iOS的渲染流程"><a href="#理解iOS的渲染流程" class="headerlink" title="理解iOS的渲染流程"></a>理解iOS的渲染流程</h2><h3 id="渲染系统框架"><a href="#渲染系统框架" class="headerlink" title="渲染系统框架"></a>渲染系统框架</h3><p><img src="uikit_stack.png" alt="uikit_stack.png"></p>
<ul>
<li>UIKit: 包含各种控件，负责对用户操作事件的响应，本身并不提供渲染的能力</li>
<li>Core Animation: 负责所有视图的绘制、显示与动画效果</li>
<li>OpenGL ES: 提供2D与3D渲染服务</li>
<li>Core Graphics: 提供2D渲染服务</li>
<li>Graphics Hardware: 指GPU</li>
</ul>
<p>所以在iOS中，所有视图的现实与动画本质上是由 Core Animation 负责，而不是UIKit。</p>
<h3 id="Core-Animation-Pipeline-流水线"><a href="#Core-Animation-Pipeline-流水线" class="headerlink" title="Core Animation Pipeline 流水线"></a>Core Animation Pipeline 流水线</h3><p><img src="core_animation_pipeline.png" alt="uikit_stack.png"></p>
<p>Core Animation的绘制是通过Core Animation Pipeline实现，它以流水线的形式进行渲染，具体分为四个步骤：</p>
<ul>
<li>Commit Transaction:</li>
</ul>
<p>可以细分为</p>
<pre><code>- Layout: 构建视图布局如addSubview等操作

- Display: 重载drawRect:进行时图绘制，该步骤使用CPU与内存

- Prepare: 主要处理图像的解码与格式转换等操作

- Commit: 将Layer递归打包并发送到Render Server</code></pre><ul>
<li><p>Render Server:</p>
<p>  负责渲染工作，会解析上一步Commit Transaction中提交的信息并反序列化成渲染树（render tree)，随后根据layer的各种属性生成绘制指令，并在下一次VSync信号到来时调用OpenGL进行渲染。</p>
</li>
<li><p>GPU:</p>
<p>  GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。</p>
</li>
<li><p>Dispaly:</p>
<p>  从缓冲区中取出画面，并输出到屏幕上。</p>
</li>
</ul>
<h3 id="知识补充：iOS的VSync与双缓冲机制"><a href="#知识补充：iOS的VSync与双缓冲机制" class="headerlink" title="知识补充：iOS的VSync与双缓冲机制"></a>知识补充：iOS的VSync与双缓冲机制</h3><h4 id="VSync"><a href="#VSync" class="headerlink" title="VSync:"></a>VSync:</h4><p>VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。</p>
<p>这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。</p>
<h4 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h4><p>双缓冲机制是用于避免或减少画面闪烁的问题，在单缓冲的情况下，GPU输出了一帧画面，缓冲区就需要马上获取这个画面，并交给显示屏去显示，而这段时间GPU输出的画面就全都丢失了，因为没有缓冲区去承载这些画面，就会造成画面的闪烁。</p>
<p>而在双缓冲机制下有一个Back Frame Buffer和一个Front Frame Buffer，在GPU绘制完成后，它会将图像先保存到Back Frame Buffer中，操作完毕后，会调用一个交换函数，让绘制完成的Back Frame Buffer上的图像交换到Front Frame Buffer上。由于双缓冲利用了更多显存与CPU消耗时间，从而避免了画面的闪烁。</p>
<p>相信大家都会遇到过应用卡顿，卡顿的原因就是因为两帧的刷新时间间隔大于60帧每秒（约16.67ms），导致用户感觉点击或者滑动时，界面没有及时的响应。</p>
<p>前面提到Core Animation Pipeline是以流水线的形式工作的，在理想的状况下我们希望它能够在1/60s内完成图层树的准备工作并提交给渲染进程，而渲染进程在下一次VSync信号到来的时候提交给GPU进行渲染，并在1/60s内完成渲染，这样就不会产生任何的卡顿。</p>
<p>但是由于我们使用了我们的魔法UIKit，所以我们在许多后台线程进行了UI操作，在runloop的结尾准备进行渲染的时候，不同线程提交了不同的渲染信息，于是我们就拥有了更多的绘制事务，这个时候Core Animation Pipeline会不断将信息提交，让GPU进行渲染，由于绘制事件的不同步导致了GPU渲染的不同步，可能在上一帧是需要渲染一个label消失的画面，下一帧却又需要渲染这个label改变了文字，最终导致的是界面的不同步。</p>
<p>另一方面，在VSync和双缓冲机制我们可以看出渲染其实是一个十分消耗系统资源的操作（占用显存与CPU），所以可能会因为大量的事务和线程之间频繁的上下文切换导致了GPU无法处理，反而影响了性能，从而导致在1/60s中无法完成图层树的提交，导致了严重的卡顿。</p>
<h4 id="Texture-or-ComponentKit-实现支持异步更新UI框架"><a href="#Texture-or-ComponentKit-实现支持异步更新UI框架" class="headerlink" title="Texture or ComponentKit 实现支持异步更新UI框架"></a>Texture or ComponentKit 实现支持异步更新UI框架</h4><ul>
<li><p>AsyncDisplayKit（现命名为Texture） 是Facebook开源的一个用于保持iOS界面流畅的框架。</p>
</li>
<li><p>ComponentKit是Facebook开源的一个基于React思想的iOS原生UI开发框架。它通过函数式和声明的方式构建UI。</p>
</li>
</ul>
<p>让我们撤销掉我们对UIKit施展的各种魔法，回到这个UI只能在主线程进行操作的世界吧。这两个框架其实并不是真正的在后台线程操作UI，而是用了更巧妙的方法将一些耗时的操作异步执行，从而绕开了UIKit只能在主线程操作的限制。</p>
<p>比如Texture创建了各类Node，在node中包含了UIView，而Node本身是线程安全的，所以允许在后台线程对Node进行修改，随后在第一次主线程访问View的时候它才会在内部生成对应的View，当node的属性发生改变的时候，他也不会马上进行修改，而是在适当的时机一次性的在主线程为内部的View进行设置。（有点类似于绘图循环）</p>
<p>而ComponentKit则是通过创建Component来描述UI，它也是一个线程安全的类。可以将Component认为是一个刻板，而UIView是刻板下的一张纸，渲染则是喷墨的过程。当我们生成了一个Component的时候，就等于生成了一个View的模版，在进行渲染的时候只要按照模版进行绘制就可以了。复杂的界面可以通过各种简单的Component来组成。（类似于Flutter的widget）</p>
<h4 id="子线程中如何通知主线程（队列）更新UI方法，记录一下"><a href="#子线程中如何通知主线程（队列）更新UI方法，记录一下" class="headerlink" title="子线程中如何通知主线程（队列）更新UI方法，记录一下"></a>子线程中如何通知主线程（队列）更新UI方法，记录一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一</span><br><span class="line">[self performSelectorOnMainThread:@selector(updateImage:) withObject:data waitUntilDone:YES];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法二</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新UI的代码，不用主线程中调用</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法三</span><br><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;线程2：%@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>



    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/bianchengme/tags/iOS/">iOS</a>
      
        <a href="/bianchengme/tags/UI/">UI</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/bianchengme/tags/iOS/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
  </nav>
  

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<div class='header'>jmme@foxmail.com</div>
<div class='content'>
<div class='desc'>Tempora mutantur, nos et mutamur in illis ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://ccoooss.com">
            <div class='name'>ClassicOldSong</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://frantic1048.logdown.com/">
            <div class='name'>Frantic1048</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://hclmaster.github.io/">
            <div class='name'>Hclmaster</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://whst.github.io/">
            <div class='name'>WANG Hsü-Tung</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/bianchengme/categories/Docker/"><div class='name'>Docker</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/JAVA/"><div class='name'>JAVA</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/JAVA/JVM/"><div class='name'>JVM</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/Markdown/"><div class='name'>Markdown</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/Docker/Nacos/"><div class='name'>Nacos</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/iOS/Objective-C/"><div class='name'>Objective-C</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/Windows/"><div class='name'>Windows</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/iOS/Xcode/"><div class='name'>Xcode</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/flutter/"><div class='name'>flutter</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/git/"><div class='name'>git</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/iOS/"><div class='name'>iOS</div><div class='badget'>16</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/java/"><div class='name'>java</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/mysql/"><div class='name'>mysql</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/bianchengme/categories/vue/"><div class='name'>vue</div><div class='badget'>1</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/bianchengme/tags/BUG/" style="font-size: 14px; color: #808080">BUG</a> <a href="/bianchengme/tags/Docker/" style="font-size: 14px; color: #808080">Docker</a> <a href="/bianchengme/tags/JAVA/" style="font-size: 14px; color: #808080">JAVA</a> <a href="/bianchengme/tags/JVM/" style="font-size: 14px; color: #808080">JVM</a> <a href="/bianchengme/tags/Markdown/" style="font-size: 14px; color: #808080">Markdown</a> <a href="/bianchengme/tags/Objective-C/" style="font-size: 18px; color: #2b2b2b">Objective-C</a> <a href="/bianchengme/tags/RunTime/" style="font-size: 14px; color: #808080">RunTime</a> <a href="/bianchengme/tags/Swift/" style="font-size: 14px; color: #808080">Swift</a> <a href="/bianchengme/tags/UI/" style="font-size: 16px; color: #555">UI</a> <a href="/bianchengme/tags/Windows/" style="font-size: 14px; color: #808080">Windows</a> <a href="/bianchengme/tags/Xcode/" style="font-size: 14px; color: #808080">Xcode</a> <a href="/bianchengme/tags/flutter/" style="font-size: 16px; color: #555">flutter</a> <a href="/bianchengme/tags/git/" style="font-size: 14px; color: #808080">git</a> <a href="/bianchengme/tags/hook/" style="font-size: 14px; color: #808080">hook</a> <a href="/bianchengme/tags/iOS/" style="font-size: 20px; color: #000">iOS</a> <a href="/bianchengme/tags/iOS%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C/" style="font-size: 14px; color: #808080">iOS真机运行</a> <a href="/bianchengme/tags/java/" style="font-size: 16px; color: #555">java</a> <a href="/bianchengme/tags/mysql/" style="font-size: 14px; color: #808080">mysql</a> <a href="/bianchengme/tags/nacos/" style="font-size: 14px; color: #808080">nacos</a> <a href="/bianchengme/tags/vue/" style="font-size: 14px; color: #808080">vue</a> <a href="/bianchengme/tags/%E4%BC%98%E5%8C%96/" style="font-size: 14px; color: #808080">优化</a> <a href="/bianchengme/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14px; color: #808080">多线程</a> <a href="/bianchengme/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 14px; color: #808080">学习计划</a> <a href="/bianchengme/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 14px; color: #808080">工具</a> <a href="/bianchengme/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #808080">算法</a> <a href="/bianchengme/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 14px; color: #808080">网络</a> <a href="/bianchengme/tags/%E9%83%A8%E7%BD%B2/" style="font-size: 14px; color: #808080">部署</a> <a href="/bianchengme/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 14px; color: #808080">面试</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/stkevintan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/kevinsfork" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' target="_blank" rel="noopener" class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>

<script src="/bianchengme/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/bianchengme/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>

<script src="/bianchengme/js/search.js"></script>


<script src="/bianchengme/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
</body>
</html>
