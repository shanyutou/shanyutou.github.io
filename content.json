{"meta":{"title":"山芋头","subtitle":"记录和分享能创造价值","description":"记录和总结让知识得到积累，分享能创造价值","author":"jmme@foxmail.com","url":"https://bianchengme.gitee.io/bianchengme","root":"/bianchengme/"},"pages":[{"title":"categories","date":"2020-03-31T09:16:22.000Z","updated":"2020-07-28T05:41:08.635Z","comments":true,"path":"categories/index.html","permalink":"https://bianchengme.gitee.io/bianchengme/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-31T09:42:09.000Z","updated":"2021-09-07T07:26:31.789Z","comments":true,"path":"about/index.html","permalink":"https://bianchengme.gitee.io/bianchengme/about/index.html","excerpt":"","text":"小时侯把english读为”应给利息”的同学当了行长；读为”阴沟里洗”的成了小菜贩子；读为”因果联系”的成了哲学家；读为”硬改历史”的成了政治家；读为”英国里去”的成了海外华侨；读为“应该你死”的成了野心家；而我不小心读成了”应该累死” 结果成了程序员……. 写博客是作为技术的积累和系统化； 同时也为了能收获分享的快乐； 平时的爱好就是发呆、跑步、垂钓、路亚、骑行、游泳… 邮箱: jmme@foxmial.xom"},{"title":"tags","date":"2020-03-31T09:18:35.000Z","updated":"2020-07-28T05:41:08.635Z","comments":true,"path":"tags/index.html","permalink":"https://bianchengme.gitee.io/bianchengme/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM 逃逸分析优化","slug":"JVM-逃逸分析优化","date":"2021-09-07T02:52:06.000Z","updated":"2021-09-07T09:26:03.698Z","comments":true,"path":"2021/09/07/JVM-逃逸分析优化/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2021/09/07/JVM-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96/","excerpt":"","text":"“Java 中的对象是否都分配在堆内存中？”——“不尽然” Java 中对象的创建一般会由堆内存去分配内存空间来进行存储，在堆内存空间不足的时候，GC 便会对堆内存进行垃圾回收，如果 GC 运行的次数过多，便会影响程序的性能,并且堆内存为所有线程共享，存再同步问题；所以 “逃逸分析” 由此诞生，它的目的就是判断哪些对象是可以存储在栈内存中而不用存储在堆内存中的，从而让其随着线程的消逝而消逝，进而减少了 GC 发生的频率，这也是常见的 JVM 优化技巧之一。 什么是逃逸分析逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。 在方法中创建对象之后，如果这个对象 实例 除了在方法体中还在其它地方被引用了，此时如果方法执行完毕，由于该对象有被引用，所以 GC 有可能是无法立即回收的，此时便成为 内存逃逸现象。 如何使用逃逸分析 开启逃逸分析：-XX:+DoEscapeAnalysis 关闭逃逸分析：-XX:-DoEscapeAnalysis 显示分析结果：-XX:+PrintEscapeAnalysis 逃逸分析的作用，就是筛选出没有发生逃逸的对象，从而对它们进行以下三方面的优化： 同步消除（锁消除）因为同步锁是非常消耗性能的，所以当编译器确定一个对象没有发生逃逸时，它便会移除该对象的同步锁。 在 JDK1.8 中是默认开启的，但是要建立在已开启逃逸分析的基础之上。 开启锁消除：-XX:+EliminateLocks（JDK8默认开启） 关闭锁消除：-XX:-EliminateLocks 标量替换首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。 对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。 这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。 标量替换在 JDK1.8 中也是默认开启的，但是同样也要建立在已开启逃逸分析的基础之上。 开启标量替换：-XX:+EliminateAllocations 关闭标量替换：-XX:-EliminateAllocations 显示标量替换详情：-XX:+PrintEliminateAllocations 栈内存分配栈内存分配很好理解，在上文中提过，就是将原本分配在堆内存上的对象转而分配在栈内存上，这样就可以减少堆内存的占用，从而减少 GC 的频次。 逃逸分析的优势我们通过如下代码测试： 12345678910111213141516171819202122232425262728293031323334/** * @author shanyutou.github.io * @ClassName: EscapeAnalysisTest * @Description: https://shanyutou.github.io 逸出分析测试 * @date 2021/09/07 * @Version: 1.0.0 */public class EscapeAnalysisTest &#123; public static void main(String[] args) throws InterruptedException &#123; long t1 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; allot(); &#125; long t2 = System.currentTimeMillis(); System.out.println(t2-t1); Thread.sleep(Integer.MAX_VALUE); &#125; private static void allot() &#123; Jet jet = new Jet();// synchronized (jet) &#123;// jet.name = \"jet Chen\";// &#125; &#125; static class Jet &#123; public String name; &#125;&#125; Step 1：测试开启逃逸环境是 jdk1.8，默认开启了逃逸分析，所以直接运行，得到结果如下，程序耗时 3 毫秒，没有发生GC。 Step 2：测试关闭逃逸 -XX:-DoEscapeAnalysis 得到结果如下，程序耗时 312 毫秒产生一次GC。 所以，从代码的执行时间（3 毫秒 VS 400 毫秒），还是从GC分析，在上述场景下，开启逃逸分析是有正向益的。 Step 3：测试标量替换 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations //耗时4-XX:+DoEscapeAnalysis -XX:-EliminateAllocations //耗时306-XX:-DoEscapeAnalysis -XX:+EliminateAllocations //耗时310-XX:-DoEscapeAnalysis -XX:-EliminateAllocations //耗时310 在上述极端场景下，开启和关闭标量替换对于性能的影响也是满巨大的，另外，同时也验证了标量替换功能生效的前提是逃逸分析已经开启，否则没有意义。 Step 4：测试锁消除测试锁消除，我们需要简单调整下代码，即给 allot() 方法中的内容加锁处理，如下： 123456private static void allot() &#123; Jet jet = new Jet(); synchronized (jet) &#123; jet.name = \"jet Chen\"; &#125;&#125; -XX:+DoEscapeAnalysis -XX:+EliminateLocks //耗时4-XX:+DoEscapeAnalysis -XX:-EliminateLocks //耗时308-XX:-DoEscapeAnalysis -XX:+EliminateLocks //耗时1492-XX:-DoEscapeAnalysis -XX:-EliminateLocks //耗时1493然后我们运行测试代码，测试结果也很明显，在上述场景下，开启和关闭锁消除对程序性能的影响也是巨大的。同时也验证了标量替换功能生效的前提是逃逸分析已经开启，否则没有意义。 总结逃逸分析的原理理解起来其实很简单，但 JVM 在实际应用过程中，还是有诸多因素需要考虑的。 比如，逃逸分析不能在静态编译时进行，必须在 JIT 里完成。原因大致是：与 Java 的动态性有冲突。因为你可以在运行时，通过动态代理改变一个类的行为，此时，逃逸分析是无法得知类已经变化了。总之就是：因为只有当收集到足够的运行数据时，JVM 才可以更好地判断对象是否发生了逃逸。（参考大佬的解释：https://www.zhihu.com/ques....） 当然，逃逸分析并不是没有劣势的，因为逃逸分析是需要消耗一定的性能去执行分析的，所以说如果方法中的对象全都是处于逃逸状态，那么就没有起到优化的作用，从而就白白损失了这部分的性能消耗。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://bianchengme.gitee.io/bianchengme/categories/JAVA/"},{"name":"JVM","slug":"JAVA/JVM","permalink":"https://bianchengme.gitee.io/bianchengme/categories/JAVA/JVM/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://bianchengme.gitee.io/bianchengme/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://bianchengme.gitee.io/bianchengme/tags/JVM/"},{"name":"优化","slug":"优化","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"Nacos通过Docke部署","slug":"Nacos通过Docke部署","date":"2021-07-02T01:28:53.000Z","updated":"2021-07-02T01:46:47.747Z","comments":true,"path":"2021/07/02/Nacos通过Docke部署/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2021/07/02/Nacos%E9%80%9A%E8%BF%87Docke%E9%83%A8%E7%BD%B2/","excerpt":"","text":"方式一1.拉取镜像1docker pull nacos/nacos-server 2.挂载目录12mkdir -p ~/data/nacos/logs/ ~/data/nacos/init.d/ #创建目录 vim ~/data/nacos/init.d/application.properties #修改配置文件 添加如下参数: 12345678910111213141516171819202122232425262728293031323334server.contextPath=/nacosserver.servlet.contextPath=/nacosserver.port=8848spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=userdb.password=passnacos.cmdb.dumpTaskInterval=3600nacos.cmdb.eventTaskInterval=10nacos.cmdb.labelTaskInterval=300nacos.cmdb.loadDataAtStart=falsemanagement.metrics.export.elastic.enabled=falsemanagement.metrics.export.influx.enabled=falseserver.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D %&#123;User-Agent&#125;inacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**nacos.naming.distro.taskDispatchThreadCount=1nacos.naming.distro.taskDispatchPeriod=200nacos.naming.distro.batchSyncKeyCount=1000nacos.naming.distro.initDataRatio=0.9nacos.naming.distro.syncRetryDelay=5000nacos.naming.data.warmup=truenacos.naming.expireInstance=true :wq 保存退出 3.启动容器123456789101112docker run \\--name nacos -d \\-p 8848:8848 \\--privileged=true \\--restart=always \\-e JVM_XMS=256m \\-e JVM_XMX=256m \\-e MODE=standalone \\-e PREFER_HOST_MODE=hostname \\-v ~/data/nacos/logs/:/home/nacos/logs \\-v ~/data/nacos/init.d/application.properties:/home/nacos/init.d/application.properties \\nacos/nacos-server","categories":[{"name":"Docker","slug":"Docker","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Docker/"},{"name":"Nacos","slug":"Docker/Nacos","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Docker/Nacos/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Docker/"},{"name":"nacos","slug":"nacos","permalink":"https://bianchengme.gitee.io/bianchengme/tags/nacos/"},{"name":"部署","slug":"部署","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"centos7 安装mysql5.7","slug":"centos7-安装mysql5-7","date":"2021-05-09T12:12:54.000Z","updated":"2021-09-07T07:26:31.782Z","comments":true,"path":"2021/05/09/centos7-安装mysql5-7/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2021/05/09/centos7-%E5%AE%89%E8%A3%85mysql5-7/","excerpt":"","text":"创建用户和组 12groupadd mysql useradd -g mysql -s &#x2F;sbin&#x2F;nologin mysql 解压到指定目录并重命名 12#dev.mysql.com 下载 linux 通用二进制包tar xzvf XXX.tar.gz &#x2F;usr&#x2F;local&#x2F;mysql 配置环境变量 123echo &quot;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile 创建数据目录，并配置权限 123456789101112131415mkdir -p &#x2F;data&#x2F;mysql&#x2F;&#123;data,binlogs,log,etc,run&#125;ln -s &#x2F;data&#x2F;mysql&#x2F;data &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;dataln -s &#x2F;data&#x2F;mysql&#x2F;binlogs &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;binlogsln -s &#x2F;data&#x2F;mysql&#x2F;log &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;logln -s &#x2F;data&#x2F;mysql&#x2F;etc &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;etcln -s &#x2F;data&#x2F;mysql&#x2F;run &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;runchown -R mysql.mysql &#x2F;data&#x2F;mysql&#x2F; # 设置文件夹为第一步创建的用户组、用户的权限chown -R mysql.mysql &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;&#123;data,binlogs,log,etc,run&#125; # 设置文件夹为第一步创建的用户组、用户 删除系统自带的my.cnf 1rm -f &#x2F;etc&#x2F;my.cnf 在/usr/local/mysql/etc/下创建my.cnf文件，加入如下参数 1234567891011121314151617181920212223242526272829303132[client]port &#x3D; 3306socket &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysql.sock[mysqld]pid_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysql.piddatadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;datasocket &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysql.sockmax_connections &#x3D; 2048open_files_limit &#x3D; 65535skip-name-resolvelower_case_table_names&#x3D;1character-set-server &#x3D; utf8mb4collation-server &#x3D; utf8mb4_unicode_ciinit_connect&#x3D;&#39;SET NAMES utf8mb4&#39;innodb_buffer_pool_size &#x3D; 1024Minnodb_log_file_size &#x3D; 2048Minnodb_file_per_table &#x3D; 1innodb_flush_log_at_trx_commit &#x3D; 0key_buffer_size &#x3D; 64Mlog-error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql_error.loglog-bin &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;binlogs&#x2F;mysql-binslow_query_log &#x3D; 1slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql_slow_query.loglong_query_time &#x3D; 5 tmp_table_size &#x3D; 32Mmax_heap_table_size &#x3D; 32Mquery_cache_type &#x3D; 0query_cache_size &#x3D; 0server-id&#x3D;1 初始化mysql 1mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data 记住生成的root密码 1grep &#39;temporary password&#39; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql_error.log 生成ssl 1mysql_ssl_rsa_setup --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F; 配置系统服务 123456789101112131415161718192021222324252627282930313233cd &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system touch mysqld.service #并加入以下内容[Unit]Description&#x3D;MySQL ServerDocumentation&#x3D;man:mysqld(8)Documentation&#x3D;http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;en&#x2F;using-systemd.htmlAfter&#x3D;network.targetAfter&#x3D;syslog.target[Install]WantedBy&#x3D;multi-user.target[Service]User&#x3D;mysqlGroup&#x3D;mysqlType&#x3D;forkingPIDFile&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysqld.pid \\# Disable service start and stop timeout logic of systemd for mysqld service.TimeoutSec&#x3D;0\\# Execute pre and post scripts as rootPermissionsStartOnly&#x3D;true\\# Needed to create system tables\\#ExecStartPre&#x3D;&#x2F;usr&#x2F;bin&#x2F;mysqld_pre_systemd\\# Start main serviceExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld --daemonize --pid-file&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysqld.pid $MYSQLD_OPTS\\# Use this to switch malloc implementationEnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;mysql\\# Sets open_files_limitLimitNOFILE &#x3D; 65535 Restart&#x3D;on-failure RestartPreventExitStatus&#x3D;1 PrivateTmp&#x3D;false 启动mysql服务以及开机自启动 12systemctl enable mysqldsystemctl start mysqld 用步骤8中的root密码进行登录，第一次登陆需要设置密码 1alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;root&#39; # 只能通过该方法修改； 过程中遇到错误 1ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;run&#x2F;mysql.sock&#39; (2) 分析：在/usr/local/mysql/run/mysql.sock 位置没有找到mysql.sock；通过命令 find / -name mysqld.sock , 发现mysql。sock 位置不对，不是my.cnf配置位置，shy? 一番尝试发现 my.cnf,可以发现问题源头,不光[client] 中配置socket地址，[mysqld]中也要配置socket地址（上文已经更正错误），还是没有理解配置。。。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://bianchengme.gitee.io/bianchengme/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://bianchengme.gitee.io/bianchengme/tags/mysql/"}]},{"title":"openstack-horizon 快速本地运行","slug":"openstack-horizon-快速本地运行","date":"2021-03-12T08:31:55.000Z","updated":"2021-03-12T10:14:39.171Z","comments":true,"path":"2021/03/12/openstack-horizon-快速本地运行/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2021/03/12/openstack-horizon-%E5%BF%AB%E9%80%9F%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C/","excerpt":"","text":"horizon 简介Horizon 为 Openstack 提供一个 WEB 前端的管理界面 (UI 服务 )通过 Horizon 所提供的 DashBoard 服务 , 管理员可以使用通过 WEB UI 对 Openstack 整体云环境进行管理 , 并可直观看到各种操作结果与运行状态。那作为开发者怎样快速上手horizon？其实很简单，so easy！ horizon本地运行1、准备本地环境安装python，不会自己百度搜吧 。。。。 2、创建虚拟环境，推荐用virtualenvwrapper；12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 安装pip install virtualenvwrapper-win&#x2F;*** 默认创建的虚拟环境位于C:\\Users\\username\\envs,可以通过环境变量 WORKON_HOME来定制。* 通过计算机--&gt;属性--&gt;高级系统设置--&gt;环境变量--&gt;在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。*&#x2F;&#x2F;&#x2F; 执行此命令创建第一个虚拟环境:mkvirtualenv venv&#x2F;&#x2F; 列出所有虚拟环境lsvirtualenv&#x2F;&#x2F; 激活虚拟环境workon venv&#x2F;&#x2F; 进入虚拟环境目录cdvirtualenv&#x2F;&#x2F; 进入虚拟环境的site-packages目录cdsitepackages&#x2F;&#x2F; 列出site-packages目录的所有软件包lssitepackages&#x2F;&#x2F; 停止虚拟环境deactivate&#x2F;&#x2F; 删除虚拟环境rmvitualenv venv 3、 获取项目代码12# github clone 地址https:&#x2F;&#x2F;github.com&#x2F;openstack&#x2F;horizon.git 4、安装依赖12&#x2F;&#x2F;项目目录下:pip install -r requirements.txt 5、配置项目12&#x2F;&#x2F; 创建配置文件cp openstack_dashboard&#x2F;local&#x2F;local_settings.py.example openstack_dashboard&#x2F;local&#x2F;local_settings.py 6、运行项目123python manage.py runserver&#x2F;&#x2F;访问localhost:8000 打开登录界面；OK 7、过程中遇到的问题1234567Exception has occurred: FilePermissionErrorInsecure permissions on key file &#x2F;mnt&#x2F;f&#x2F;work&#x2F;openstack&#x2F;horizon&#x2F;openstack_dashboard&#x2F;local&#x2F;.secret_key_store, should be 0600&#x2F;&#x2F; 可能是linux文件权限错误，搜索后发现，local_settings.py使用了该文件，修改权限后依然不行，可能是我用了wsl的原因吧。&#x2F;&#x2F; 暂时先屏蔽 horizon&#x2F;openstack_dashboard&#x2F;local&#x2F;local_settings.py中对.secret_key_store的使用# SECRET_KEY &#x3D; secret_key.generate_or_read_from_file(os.path.join(LOCAL_PATH, &#39;.secret_key_store&#39;))SECRET_KEY&#x3D;&#39;GUM4T1AwQbF536JpKNQk10Vq0EpOIIudUQ0hpoAPBdTvDkgvUuuuGagAE4xajUVx&#39;","categories":[],"tags":[]},{"title":"用npm安装sass教程和常见错误","slug":"用npm安装sass教程和常见错误","date":"2020-10-11T08:41:39.000Z","updated":"2021-09-07T07:26:31.786Z","comments":true,"path":"2020/10/11/用npm安装sass教程和常见错误/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/10/11/%E7%94%A8npm%E5%AE%89%E8%A3%85sass%E6%95%99%E7%A8%8B%E5%92%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","excerpt":"","text":"用npm安装sass经常出错，原因是安装包比较大，并且源在国外，所以网络不好情况下容易安装失败；另外还依赖python环境，缺乏python环境也会安装失败。 为保障安装成功，做一些配置即可安装成功： 方法一：使用淘宝源, 这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载。 12345npm config set sass_binary_site&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass&#x2F;npm config set phantomjs_cdnurl&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;phantomjs&#x2F;npm config set electron_mirror&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;npm config set registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 方法二：安装cnpm &gt;&gt;&gt; 也是淘宝源的做法 12npm install -g cnpmcnpm install 方法三：使用VPN 1234npm config set proxy (http:&#x2F;&#x2F;127.0.0.1:1080) #此处是VPN的代理地址npm i node-sass# 下载完成后删除 http 代理npm config delete proxy 在安装过程中注意查看全部报错信息，比如会提示找不到 Python、找不到某个版本等等错误。按照问题分析解决即可： 提示没有Python环境这个很好解决，安装Pyhon，并确保配置好环境变量即可。 提示找不到某个版本安装的时候如果指定了某个版本，可能淘宝源上没有指定要的版本，访问https://npm.taobao.org/mirrors/node-sass/ 看存在哪些版本切换为相近版本即可。","categories":[],"tags":[]},{"title":"项目基线目录-方便项目管理与交接","slug":"项目基线目录-方便项目管理与交接","date":"2020-10-11T06:57:25.000Z","updated":"2021-09-07T07:26:31.786Z","comments":true,"path":"2020/10/11/项目基线目录-方便项目管理与交接/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/10/11/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%BA%BF%E7%9B%AE%E5%BD%95-%E6%96%B9%E4%BE%BF%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BA%A4%E6%8E%A5/","excerpt":"","text":"基线 (Baseline) 说起 . 基线是软件文档或源码 ( 或其它产出物 ) 的一个稳定版本 , 它是进一步开发的基础 . 所以 , 当基线形成后 , 项目负责 SCM 的人需要通知相关人员基线已经形成 , 并且哪儿可以找到这基线了的版本 . 这个过程可被认为内部的发布 . 至于对外的正式发布 , 更是应当从基线了的版本中发布 . ​ 基线是项目储存库中每个工件版本在特定时期的一个 “ 快照 ” 。它提供一个正式标准，随后的工作基于此标准，并且只有经过授权后才能变更这个标准。建立一个初始基线后，以后每次对其进行的变更都将记录为一个差值，直到建成下一个基线。 ​ 参与项目的开发人员将基线所代表的各版本的目录和文件填入他们的工作区。随着工作的进展，基线将合并自从上次建立基线以来开发人员已经交付的工作。变更一旦并入基线，开发人员就采用新的基线，以与项目中的变更保持同步。调整基线将把集成工作区中的文件并入开发工作区。 ​ 建立基线的三大原因是：重现性、可追踪性和报告。 ​ 重现性是指及时返回并重新生成软件系统给定发布版的能力，或者是在项目中的早些时候重新生成开发环境的能力。可追踪性建立项目工件之间的前后继承关系。其目的在于确保设计满足要求、代码实施设计以及用正确代码编译可执行文件。报告来源于一个基线内容同另一个基线内容的比较。基线比较有助于调试并生成发布说明。 ​ 建立基线后，需要标注所有组成构件和基线，以便能够对其进行识别和重新建立。 建立基线有以下几个优点： 基线为开发工件提供了一个定点和快照。 新项目可以从基线提供的定点之中建立。作为一个单独分支，新项目将与随后对原始项目（在主要分支上）所进行的变更进行隔离。 各开发人员可以将建有基线的构件作为他在隔离的私有工作区中进行更新的基础。 当认为更新不稳定或不可信时，基线为团队提供一种取消变更的方法。 您可以利用基线重新建立基于某个特定发布版本的配置，这样也可以重现已报告的错误。 使用 ​ 定期建立基线以确保各开发人员的工作保持同步。但是，在项目过程中，应该在每次迭代结束点（次要里程碑），以及与生命周期各阶段结束点相关联的主要里程碑处定期建立基线： ​ 生命周期目标里程碑（先启阶段）​ 生命周期构架里程碑（精化阶段）​ 初始操作性能里程碑（构建阶段）​ 产品发布里程碑（产品化阶段） 基线目录结构 ​ 克隆地址 https://github.com/shanyutou/Project-Baseline-Catalogue.git 项目中同时不断积累各种文档模板与画图方法，目的在于提高程序员的文档能力。","categories":[],"tags":[]},{"title":"Spring boot api 生成工具 apiDoc vs swagger and JApiDocs","slug":"Spring-boot-api-生成工具-apiDoc-vs-swagger-and-JApiDocs","date":"2020-09-09T14:19:23.000Z","updated":"2021-09-07T07:26:31.782Z","comments":true,"path":"2020/09/09/Spring-boot-api-生成工具-apiDoc-vs-swagger-and-JApiDocs/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/09/09/Spring-boot-api-%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7-apiDoc-vs-swagger-and-JApiDocs/","excerpt":"","text":"曾经看过这样一个笑话：程序员最讨厌写文档，比这个还讨厌的事情就是，别人居然不写文档。 文档的确是个令猿头疼的东西哇，但是文档的重要性也是不言而喻。这里就给大家安利两款比较好用的接口文档生成工具： apidoc 比较好用的静态生成工具，生成静态api文档非常合适； swagger功能强大的动态api工具，带有调试功能，knife4j是对swaggerUI封装的优化，更适合国人风格； Japidocs 新开源的静态生成工具用的人虽然没有上面两个多，但是只需要java环境即可，也是不错的api生成工具，值得尝试。 1. apidoc简介apidoc是一款可以由源代码中的注释直接自动生成api接口文档的工具，它几乎支持目前主流的所有风格的注释。 使用首先你的环境必须要安装了node.js.然后通过以下的命令安装apidoc： npm install apidoc -g 在你的项目根目录下添加apidoc.json文件，这个文件主要包含一些项目的描述信息，例如标题、介绍、版本等。 12345678&#123; &quot;name&quot;: &quot;example&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;apiDoc basic example&quot;, &quot;title&quot;: &quot;Custom apiDoc browser title&quot;, &quot;url&quot; : &quot;https:&#x2F;&#x2F;api.github.com&#x2F;v1&quot;&#125;1234567 在你的代码注释里加入apidoc的注解，例如这样子： 1234567891011121314151617181920212223 &#x2F;** * @apiGroup Product * @api &#123;GET&#125; &#x2F;product&#x2F;&#123;id&#125; 查询一个产品 * @apiDescription 指定产品id , 删除产品的全部信息，包括关联的schema * @apiParam &#123;String&#125; id 产品id(必填*) * @apiSuccessExample SuccessExample * HTTP&#x2F;1.1 200 * &#123; * id: &#39;xxx&#39;, * modelId: &#39;xxxxx&#39;, * name: &#39;xxx&#39;, * intro: &#39;xxxx&#39; * &#125; * @apiErrorExample ErrorExample * HTTP&#x2F;1.1 600 * 具体的异常信息 *&#x2F; @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;) public Product getOneProduct(@PathVariable String id) &#123; return productServ.findOne(id); &#125;12345678910111213141516171819202122 常用的一些注解如下： 123456789@api 定义API的请求方法、路径和名字@apiDescription 定义API的描述@apiGroup 定义API的分组@apiParam 定义API的参数@apiParamExample 参数请求的事例@apiVersion 版本@apiErrorExample API错误示例@apiSuccessExample API正常示例12345678 然后就可以利用apidoc的命令来生成接口文档了： 然后当前目录下会生成一个新的apidoc目录，就是新生成的接口文档文件。 打开 index.html 即可看到生成的接口文档： 2. swagger在这里俺用 springBoot 整合swagger2 做了个Restful Api 的接口小demo github 源码传送门☛☛☛ 首先项目中得添加swagger2的依赖： 12345678910111213&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;123456789101112 创建swagger2 的配置类： 123456789101112131415161718192021222324@Configuration@EnableSwagger2public class SwaggerConfig&#123; public Docket createApi()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.miao.springbootswagger&quot;)) .paths(PathSelectors.any()) .build(); &#125; &#x2F;&#x2F; 创建api的基本信息 private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(&quot;springBoot 整合 Swagger2 实例&quot;) .description(&quot;更多技术内容分享见博客：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24871519&quot;) .termsOfServiceUrl(&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24871519&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125;1234567891011121314151617181920212223 为接口添加swagger的注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@RestController@RequestMapping(&quot;&#x2F;user&quot;)public class UserController&#123; private static Map&lt;String, User&gt; users&#x3D;new ConcurrentHashMap&lt;&gt;(); @ApiOperation(value &#x3D; &quot;添加用户&quot;, notes &#x3D; &quot;添加一条用户信息&quot;) @ApiImplicitParam(name &#x3D; &quot;user&quot;, value &#x3D; &quot;用户详细实体user&quot;, required &#x3D; true, dataType &#x3D; &quot;User&quot;) @PostMapping(&quot;&#x2F;add&quot;) public User add(User user)&#123; String id&#x3D;UUID(); while(users.containsKey(id))&#123; id&#x3D;UUID(); &#125; user.setId(id); users.put(id, user); return user; &#125; @ApiOperation(value &#x3D; &quot;获取一个用户&quot;, notes &#x3D; &quot;根据用户id获取用户信息&quot;) @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;用户ID&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;) @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;) public User getOne(@PathVariable String id)&#123; if(!users.containsKey(id))&#123; return null; &#125; return users.get(id); &#125; @ApiOperation(value &#x3D; &quot;获取所有用户信息列表&quot;) @GetMapping(&quot;&#x2F;&quot;) public List&lt;User&gt; getUsers()&#123; return new ArrayList&lt;&gt;(users.values()); &#125; @ApiOperation(value &#x3D; &quot;更新用户信息&quot;) @ApiImplicitParam(name &#x3D; &quot;user&quot;, value &#x3D; &quot;用户信息实体&quot;,required &#x3D; true, dataType &#x3D; &quot;User&quot;) @PutMapping(&quot;&#x2F;&quot;) public User updateOne(User u)&#123; User tmp &#x3D; users.get(u.getId()); if(tmp &#x3D;&#x3D; null)&#123; return null; &#125; if(u.getName()!&#x3D;null)&#123; tmp.setName(u.getName()); &#125; if(u.getAge() !&#x3D; null)&#123; tmp.setAge(u.getAge()); &#125; return tmp; &#125; @ApiOperation(value &#x3D; &quot;删除用户&quot;) @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;用户ID&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;) @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;) public void delete(@PathVariable String id)&#123; if(users.containsKey(id))&#123; users.remove(id); &#125; &#125; private String UUID()&#123; return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 上述都完成后，启动springBoot 项目，访问 http://localhost:/swagger-ui.html 即可访问接口文档页面，具体页面如下： 3、JApiDocs是一个无需额外注解、开箱即用的SpringBoot接口文档生成工具JApiDocs是一个无需额外注解、开箱即用的SpringBoot接口文档生成工具。 编写和维护API文档这个事情，对于后端程序员来说，是一件恼人但又不得不做的事情，我们都不喜欢写文档，但除非项目前后端代码都是自己写的，否则API文档将是前后端协作中一个不可或缺的沟通界面。 既然不可避免，那就想办法弄个轮子吧。人生苦短，必须偷懒。 相比Swagger要写一堆注解，Spring RestDocs需要写测试用例，才能生成API文档。JApiDocs 具有无痛集成的特点，你只需花几分钟就能知道它怎么用了。 快速开始 要使得JApiDcos正确工作，你写的代码应该是像下面的样子的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*** 用户接口*/@RequestMapping(\"/api/user/\")@RestControllerpublicclassUserController&#123;/** * 用户列表*@paramlistForm */@RequestMapping(path =\"list\", method = &#123;RequestMethod.GET, RequestMethod.POST&#125; )publicApiResult&gt; list(UserListForm listForm)&#123;returnnull;&#125;/** * 保存用户*@paramuserForm */@PostMapping(path =\"save\")publicApiResult saveUser(@RequestBodyUserForm userForm)&#123;returnnull;&#125;&#125; 我们给Controller类和方法加上必要的注释，给接口方法返回相关的对象类型。是的，这样JApiDocs就能解析到相关的接口信息了，就跟我们平时写的代码是差不多的，但要注意，你要通过@param来告诉JApiDocs接口的参数，但在IDE的帮助下，这个工作将是轻松愉悦的： 然后你在任意一个main入口方法执行下面的代码就可以生成文档了： 1234567891011121314DocsConfigconfig&#x3D; new DocsConfig();config.setProjectPath(&quot;your springboot project path&quot;); &#x2F;&#x2F; 项目根目录config.setProjectName(&quot;ProjectName&quot;); &#x2F;&#x2F; 项目名称config.setApiVersion(&quot;V1.0&quot;); &#x2F;&#x2F; 声明该API的版本config.setDocsPath(&quot;your api docs path&quot;); &#x2F;&#x2F; 生成API 文档所在目录config.setAutoGenerate(Boolean.TRUE); &#x2F;&#x2F; 配置自动生成Docs.buildHtmlDocs(config); &#x2F;&#x2F; 执行生成文档 接下来你只管好好写代码，生成Api文档的工作就可以交给JApiDocs了，你不需要再为额外编写和维护文档而烦恼。 功能特性 1、代码即文档 JApiDocs是通过直接解析SpringBoot的源码语法来工作的，所以只要Controller的语法符合一定的代码规范，有合理的注释，就可以直接导出文档。 2、支持导出HTML 便捷的导航和接口查看界面；可本地预览，或者部署到HTTP服务器。推荐部署到服务器，方便前后端展开协作。 3、同步导出客户端Model代码 支持导出Android端的 Java 和iOS端的 Object C Model代码，减少前端程序员的重复编码工作。 4、更多特性 支持接口搜索；支持不同版本和英文文档；自定义扩展等。 简洁的文档 再好用的东西，如果没有文档说明，别人也无从入手。为了让大家尽快上手，JApiDocs准备了一份极简的文档说明，确保你在几分钟就能用上JApiDocs。 花5分钟不到就能认识一个提高工作效率的工具，让你把更多的时间花在更加有价值的事情上，你确认不看一下吗？ “ 仓库地址： https://github.com/YeDaxia/JApiDocs 中文文档： https://japidocs.agilestudio.cn/#/zh-cn/","categories":[],"tags":[]},{"title":"Java enum常见的用法","slug":"Java-enum常见的用法","date":"2020-08-09T03:00:12.000Z","updated":"2021-09-07T07:26:31.780Z","comments":true,"path":"2020/08/09/Java-enum常见的用法/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/08/09/Java-enum%E5%B8%B8%E8%A7%81%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"一,常量定义123public enum WeekDay &#123; SUN, MON, TUE, WED, THT, FRI, SAT&#125; 二,swich123456789101112131415public enum WeekDay &#123; SUN, MON, TUE, WED, THT, FRI, SAT&#125;public class SelectDay&#123; WeekDay weekday = WeekDay.SUN; public void select()&#123; switch(weekday)&#123; case SUN: weekday = WeekDay.SUN; bread; ... &#125; &#125;&#125; 三,向枚举添加新方法1234567891011121314151617181920212223242526272829303132333435363738394041public enum Color &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; &#125; 四,覆盖枚举方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public enum Color &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //覆盖方法 @Override public String toString() &#123; return this.index+\"_\"+this.name; &#125; &#125; 五,实现接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public interface Behaviour &#123; void print(); String getInfo(); &#125; public enum Color implements Behaviour&#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //接口方法 @Override public String getInfo() &#123; return this.name; &#125; //接口方法 @Override public void print() &#123; System.out.println(this.index+\":\"+this.name); &#125; &#125; 六,接口组织枚举1234567891011121314151617181920212223242526272829public interface Food &#123; enum Coffee implements Food&#123; BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO &#125; enum Dessert implements Food&#123; FRUIT, CAKE, GELATO &#125; &#125; 七,枚举集合123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; EnumSet&lt;WeekDay&gt; week = EnumSet.noneOf(WeekDay.class); week.add(WeekDay.MON); System.out.println(\"EnumSet中的元素：\" + week); week.remove(WeekDay.MON); System.out.println(\"EnumSet中的元素：\" + week); week.addAll(EnumSet.complementOf(week)); System.out.println(\"EnumSet中的元素：\" + week); week.removeAll(EnumSet.range(WeekDay.FRI, WeekDay.SAT)); System.out.println(\"EnumSet中的元素：\" + week); &#125;","categories":[],"tags":[]},{"title":"@Autowired与@Resource的区别","slug":"Autowired与-Resource的区别","date":"2020-08-08T13:57:31.000Z","updated":"2021-09-07T07:26:31.780Z","comments":true,"path":"2020/08/08/Autowired与-Resource的区别/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/08/08/Autowired%E4%B8%8E-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"参考博文： http://www.cnblogs.com/happyyang/articles/3553687.html http://blog.csdn.net/revent/article/details/49203619 http://blog.csdn.net/ad921012/article/details/49679745 spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Autowired 与@Resource的区别： 1、 @Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。 2、 @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下： 1@Autowired&#96;&#96;()&#96;&#96;@Qualifier&#96;&#96;(&#96;&#96;&quot;baseDao&quot;&#96;&#96;)&#96;&#96;private&#96;&#96;BaseDao baseDao; 3、@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 1@Resource&#96;&#96;(name&#x3D;&#96;&#96;&quot;baseDao&quot;&#96;&#96;)&#96;&#96;private&#96;&#96;BaseDao baseDao; 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。 spring @Qualifier注解 @Autowired是根据类型进行自动装配的。如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出BeanCreationException异常;如果Spring上下文中不存在UserDao类型的bean，也会抛出BeanCreationException异常。我们可以使用@Qualifier配合@Autowired来解决这些问题。如下： ①可能存在多个UserDao实例 [java]view plaincopy @Autowired @Qualifier(“userServiceImpl”) public IUserService userService; 或者 [java]view plaincopy @Autowired public \\void setUserDao(@Qualifier(“userDao”) UserDao userDao) {**** this.userDao = userDao; } 这样Spring会找到id为userServiceImpl和userDao的bean进行装配。 ②可能不存在UserDao实例 [java]view plaincopy @Autowired(required = false) public IUserService userService 个人总结： @Autowired//默认按type注入@Qualifier(“cusInfoService”)//一般作为@Autowired()的修饰用@Resource(name=”cusInfoService”)//默认按name注入，可以通过name和type属性进行选择性注入 一般@Autowired和@Qualifier一起用，@Resource单独用。 当然没有冲突的话@Autowired也可以单独用 ———–常用注解——– –定义Bean的注解 @Controller @Controller(“Bean的名称”) 定义控制层Bean,如Action @Service @Service(“Bean的名称”) 定义业务层Bean @Repository @Repository(“Bean的名称”) 定义DAO层Bean @Component 定义Bean, 不好归类时使用. –自动装配Bean （选用一种注解就可以） @Autowired (Srping提供的) 默认按类型匹配,自动装配(Srping提供的)，可以写在成员属性上,或写在setter方法上 @Autowired(required=true) 一定要找到匹配的Bean，否则抛异常。 默认值就是true @Autowired @Qualifier(“bean的名字”) 按名称装配Bean,与@Autowired组合使用，解决按类型匹配找到多个Bean问题。 @Resource JSR-250提供的 默认按名称装配,当找不到名称匹配的bean再按类型装配. 可以写在成员属性上,或写在setter方法上 可以通过@Resource(name=”beanName”) 指定被注入的bean的名称, 要是未指定name属性, 默认使用成员属性的变量名,一般不用写name属性. @Resource(name=”beanName”)指定了name属性,按名称注入但没找到bean, 就不会再按类型装配了. @Inject 是JSR-330提供的 按类型装配，功能比@Autowired少，没有使用的必要。 –定义Bean的作用域和生命过程 @Scope(“prototype”) 值有:singleton,prototype,session,request,session,globalSession @PostConstruct 相当于init-method,使用在方法上，当Bean初始化时执行。 @PreDestroy 相当于destory-method，使用在方法上，当Bean销毁时执行。 –声明式事务 @Transactional @Autowired @Resource @Qualifier的区别 实用理解：@Autowired @Resource 二选其一，看中哪个就用哪个。 简单理解： @Autowired 根据类型注入， @Resource 默认根据名字注入，其次按照类型搜索 @Autowired @Qualifie(“userService”) 两个结合起来可以根据名字和类型注入 复杂理解： 比如你有这么一个Bean @Service(“UserService”) public Class UserServiceImpl implements UserService｛｝; 现在你想在UserController 里面使用这个UserServiceImpl public Class UserController ｛ @AutoWire //当使用这个注入的时候上面的 UserServiceImpl 只需要这样写 @Service，这样就会自动找到UserService这个类型以及他的子类型。UserServiceImpl 实现了UserService，所以能够找到它。不过这样有一个缺点，就是当UserService实现类有两个以上的时候，这个时候会找哪一个呢，这就造成了冲突，所以要用@AutoWire注入的时候要确保UserService只有一个实现类。 @Resource 默认情况下是按照名称进行匹配，如果没有找到相同名称的Bean，则会按照类型进行匹配，有人可能会想了，这下好了，用这个是万能的了，不用管名字了，也不用管类型了，但这里还是有缺点。首先，根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserService这个类上面这样写注解，@Service,它会怎么找呢，首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。也许你还会问，这里的@Service本来就没有名字，肯定是直接进行类型搜索啊。其实不是这样的，UserServiceImpl 上面如果有@Service默认的名字 是这个userServiceImpl，注意看，就是把类名前面的大写变成小写，就是默认的Bean的名字了。 @Resource根据名字搜索是这样写@Resource(“userService”)，如果你写了这个名字叫userService，那么UserServiceImpl上面必须也是这个名字，不然还是会报错。 @Autowired @Qualifie(“userService”) 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须是@Autowired @Qualifie(“userService”) 保持一致。如果@Service上面写了名字，而@Autowired @Qualifie() ，一样会报错。 private UserService userService; ｝ 说了这么多，可能你有些说晕了，那么怎么用这三个呢，要实际的工作是根据实际情况来使用的，通常使用AutoWire和@Resource多一些，bean的名字不用写，而UserServiceImpl上面能会这样写 @Service(“userService”)。这里的实际工作情况，到底是什么情况呢？说白了就是整个项目设计时候考虑的情况，如果你的架构设计师考虑的比较精细，要求比较严格，要求项目上线后的访问速度比较好，通常是考虑速度了。这个时候@AutoWire没有@Resource好用，因为@Resource可以根据名字来搜索，是这样写的@Resource(“userService”)。这个@Autowired @Qualifie(“userService”) 也可以用名字啊，为什么不用呢，原因很简单，这个有点长，不喜欢，增加工作量。因为根据名字搜索是最快的，就好像查数据库一样，根据Id查找最快。因为这里的名字与数据库里面的ID是一样的作用。这个时候，就要求你多写几个名字，工作量自然就增加了。而如果你不用注解，用xml文件的时候，对于注入Bean的时候要求写一个Id，xml文件时候的id就相当于这里的名字。 说了那么多没用，你能做的就是简单直接，什么最方便就用什么， 你就直接用@Resource得了，如果你喜欢用@AutoWire也行，不用写名字。 通常情况一个Bean的注解写错了，会报下面这些错误，最为常见， No bean named ‘user’ is defined，这个表示没有找到被命名为user的Bean，通俗的说，就是名字为user的类型，以及它的子类型，出现这个错误的原因就是注入时候的类型名字为user，而搜索的时候找不到，也就是说可能那个搜索的类型，并没有命令为user，解决办法就是找到这个类型，去命令为user， 下面这个错误也常见， No qualifying bean of type [com.service.UserService] found for dependency: 这个错误的原因就是类型上面没有加@Service这个注入，不仅仅是@Service，如果是其他层也会出现这个错误，这里我是以Service为例子说明，如果是DAO层就是没有加@Repository，Controller层，则是没有加@Controller。 还有，如果你还是想再简单点，无论是DAO,Controller，Service三个层，都可以用这个注解，@Component，这个注解通用所有的Bean，这个时候你可能会说了，有通常的为什么用的人少呢，那是因为MVC这个分层的设计原则，用@Repository,@Service，@Controller，这个可以区别MVC原则中的DAO,Service，Controller。便于识别。 博客2： springautowiredqualifierbytypebyname 在使用Spring框架中@Autowired标签时默认情况下使用 Java代码 @Autowired 1@Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。 @Autowired 默认是按照byType进行注入的，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。 例子： @Autowiredprivate ExamUserMapper examUserMapper; - ExamUserMapper是一个接口 \\1. spring先找类型为ExamUserMapper的bean \\2. 如果存在且唯一，则OK； \\3. 如果不唯一，在结果集里，寻找name为examUserMapper的bean。因为bean的name有唯一性，所以，到这里应该能确定是否存在满足要求的bean了 12@Autowired也可以手动指定按照byName方式注入，使用@Qualifier标签，例如：@Autowired&#96; &#96;() &#96;&#96;@Qualifier&#96; &#96;(&#96; &#96;&quot;baseDao&quot;&#96; &#96;) Spring 允许我们通过 Java代码 @Qualifier 1@Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，可以通过下面的方法解决异常。 Java代码 @Qualifier(“XXX”) 1@Qualifier(\"XXX\") 中的 XX是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。 @Autowired 可以对成员变量、方法以及构造函数进行注释，而 @Qualifier 的标注对象是成员变量、方法入参、构造函数入参。 Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 Java代码 @Resource 1@Resource 的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配","categories":[],"tags":[]},{"title":"SOAP 协议请求和调试","slug":"SOAP-协议请求和调试","date":"2020-08-07T14:01:37.000Z","updated":"2021-09-07T07:26:31.781Z","comments":true,"path":"2020/08/07/SOAP-协议请求和调试/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/08/07/SOAP-%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E5%92%8C%E8%B0%83%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Maven 分析项目依赖关系","slug":"Maven-分析项目依赖关系","date":"2020-08-07T12:50:48.000Z","updated":"2021-09-07T07:26:31.781Z","comments":true,"path":"2020/08/07/Maven-分析项目依赖关系/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/08/07/Maven-%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/","excerpt":"","text":"通过控制台查看：输入命令：mvn dependency:tree 如果要输出到文件，找到pom文件的位置 进入命令行输入命令： mvn dependency:tree &gt;d:/tree.txt 只查看关系的jar包mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId:version输入命令：？？？？mvn dependency:tree -Dverbose -Dincludes=org.springframework.boot:spring-boot-starter-jdbc 对结果筛选 mvn dependency:tree | grep jdbc -A5","categories":[],"tags":[]},{"title":"Java lambda表达式-箭头函数","slug":"Java-lambda表达式-箭头函数","date":"2020-08-02T05:40:50.000Z","updated":"2021-09-07T07:26:31.781Z","comments":true,"path":"2020/08/02/Java-lambda表达式-箭头函数/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/08/02/Java-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"jdk8+以上引入了箭头函数，即J8的lambda表达式。 Lambda表达式的本质只是一个”语法糖“，由编译器推断并帮你转换包装为常规的代码，因此你可以使用更少的代码来实现同样的功能。 本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘，哈哈 下面是例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s)//////////// 用法 //////////////String[] atp = &#123;\"Rafael Nadal\", \"Novak Djokovic\", \"Stanislas Wawrinka\", \"David Ferrer\",\"Roger Federer\", \"Andy Murray\",\"Tomas Berdych\", \"Juan Martin Del Potro\"&#125;; List&lt;String&gt; players = Arrays.asList(atp); // 以前的循环方式 for (String player : players) &#123; System.out.print(player + \"; \"); &#125; // 使用 lambda 表达式以及函数操作(functional operation) players.forEach((player) -&gt; System.out.print(player + \"; \")); // 在 Java 8 中使用双冒号操作符(double colon operator) players.forEach(System.out::println);String[] players = &#123;\"Rafael Nadal\", \"Novak Djokovic\", \"Stanislas Wawrinka\", \"David Ferrer\", \"Roger Federer\", \"Andy Murray\", \"Tomas Berdych\", \"Juan Martin Del Potro\", \"Richard Gasquet\", \"John Isner\"&#125;; // 1.1 使用匿名内部类根据 name 排序 players Arrays.sort(players, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.compareTo(s2)); &#125; &#125;);// 1.2 使用 lambda expression 排序 players Comparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2)); Arrays.sort(players, sortByName); // 1.3 也可以采用如下形式: Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));","categories":[{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/tags/java/"}]},{"title":"Spring boot的优点","slug":"Spring-boot的优点","date":"2020-07-30T13:58:48.000Z","updated":"2021-09-07T07:26:31.782Z","comments":true,"path":"2020/07/30/Spring-boot的优点/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/30/Spring-boot%E7%9A%84%E4%BC%98%E7%82%B9/","excerpt":"","text":"快速创建独立运行的Spring项目以及与主流框架集成； 使用嵌入式的Servelet容器，应用无需打包成WAR包； starters自动依赖与版本控制； 大量的自动配置，简化开发，也可修改默认值； 无需配置XML，无代码生成，开箱即用； 准生产环境的运行时应用监控； 与云计算的天然集成；","categories":[],"tags":[]},{"title":"Linux 生产力工具grep","slug":"Linux-生产力工具grep","date":"2020-07-28T06:11:06.000Z","updated":"2020-07-28T06:11:06.939Z","comments":true,"path":"2020/07/28/Linux-生产力工具grep/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/28/Linux-%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7grep/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux 切换启动图形界面为命令行界面","slug":"Linux-切换启动图形界面为命令行界面","date":"2020-07-28T05:49:43.000Z","updated":"2020-07-28T05:49:43.112Z","comments":true,"path":"2020/07/28/Linux-切换启动图形界面为命令行界面/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/28/Linux-%E5%88%87%E6%8D%A2%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%B8%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux 修改网络配置","slug":"Linux-修改网络配置-1","date":"2020-07-28T05:43:35.000Z","updated":"2020-07-28T05:43:35.717Z","comments":true,"path":"2020/07/28/Linux-修改网络配置-1/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/28/Linux-%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux 修改网络配置","slug":"Linux-修改网络配置","date":"2020-07-28T05:42:56.000Z","updated":"2020-07-28T05:42:56.983Z","comments":true,"path":"2020/07/28/Linux-修改网络配置/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/28/Linux-%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS中的async和await的用法和理解","slug":"JS中的async-await的用法和理解","date":"2020-07-26T13:31:47.000Z","updated":"2020-07-28T05:41:08.578Z","comments":true,"path":"2020/07/26/JS中的async-await的用法和理解/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/26/JS%E4%B8%AD%E7%9A%84async-await%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E7%90%86%E8%A7%A3/","excerpt":"","text":"首先理解async的基本含义async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数 123456789101112131415161718192021222324252627282930313233// 0. async基础用法测试async function fun0() &#123; console.log(1) return 1&#125;fun0().then( x =&gt; &#123; console.log(x) &#125;) // 输出结果 1， 1，async function funa() &#123; console.log('a') return 'a'&#125;funa().then( x =&gt; &#123; console.log(x) &#125;) // 输出结果a， a，async function funo() &#123; console.log(&#123;&#125;) return &#123;&#125;&#125;funo().then( x =&gt; &#123; console.log(x) &#125;) // 输出结果 &#123;&#125; &#123;&#125;async function funp() &#123; console.log('Promise') return new Promise(function(resolve, reject)&#123; resolve('Promise') &#125;)&#125;funp().then( x =&gt; &#123; console.log(x) &#125;) // 输出promise promise await 也是一个修饰符await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值 如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理 12345678910111213141516171819202122232425262728293031323334353637// await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值// 如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理,为undefinedconst bbb = function()&#123; return 'string'&#125;async function funAsy() &#123; const a = await 1 const b = await new Promise((resolve, reject)=&gt;&#123; setTimeout(function()&#123; resolve('time') &#125;, 3000) &#125;) const c = await bbb() console.log(a, b, c)&#125;funAsy() // 运行结果是 3秒钟之后 ，输出 1， time , string,// 2.如果不使用promise的方法的话function log2(time) &#123; setTimeout(function()&#123; console.log(time) return 1 &#125;, time)&#125;async function fun1() &#123; const a = await log2(5000) const b = await log2(10000) const c = log2(2000) console.log(a) console.log(1)&#125;fun1()// 以上运行结果为： 立刻输出undefined 立刻输出1 2秒后输出2000 5秒后输出5000 10秒后输出10000 最后async 和 await的综合用法如下1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.定义一个或多个普通函数，函数必须返回Promise对象，如果返回其他类型的数据，将按照普通同步程序处理function log(time) &#123; return new Promise((resolve, reject)=&gt; &#123; setTimeout(function()&#123; console.log(time) resolve() &#125;, time) &#125;)&#125;async function fun() &#123; await log(5000) await log(10000) log(1000) console.log(1)&#125;fun()// 2. async / await的重要应用 const asy = function(x, time) &#123; return new Promise((resolve, reject) =&gt;&#123; setTimeout(()=&gt;&#123; resolve(x) &#125;, time) &#125;)&#125;const add = async function() &#123; const a = await asy(3, 5000) console.log(a) const b = await asy(4, 10000) console.log(b) const c = await asy(5, 15000) console.log(a,b,c) const d = a + b +c console.log(d)&#125;add();// 5秒后输出3 又10秒后输出4 又15秒后输出5 然后立刻输出3,4,5，然后输出12","categories":[],"tags":[]},{"title":"Vue 插槽和作用域插槽","slug":"Vue-作用域插槽","date":"2020-07-26T11:45:11.000Z","updated":"2020-07-28T05:41:08.581Z","comments":true,"path":"2020/07/26/Vue-作用域插槽/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/07/26/Vue-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/","excerpt":"","text":"首先插槽（slot）的理解 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制如何使用插槽默认插槽父组件12345678&lt;template&gt; &lt;div&gt; 我是父组件 &lt;slotOne1&gt; &lt;p style&#x3D;&quot;color:red&quot;&gt;我是父组件插槽内容&lt;&#x2F;p&gt; &lt;&#x2F;slotOne1&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在父组件引用的子组件中写入想要显示的内容（可以使用标签，也可以不用，也可以是组件） 子组件 123456&lt;template&gt; &lt;div class&#x3D;&quot;slotOne1&quot;&gt; &lt;div&gt;我是slotOne1组件&lt;&#x2F;div&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在子组件中写入slot，slot所在的位置就是父组件要显示的内容 具名插槽子组件 12345678&lt;template&gt; &lt;div class&#x3D;&quot;slottwo&quot;&gt; &lt;div&gt;slottwo&lt;&#x2F;div&gt; &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer 父组件 123456789101112&lt;template&gt; &lt;div&gt; 我是父组件 &lt;slot-two&gt; &lt;p&gt;啦啦啦，啦啦啦，我是卖报的小行家&lt;&#x2F;p&gt; &lt;template slot&#x3D;&quot;header&quot;&gt; &lt;p&gt;我是name为header的slot&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;p slot&#x3D;&quot;footer&quot;&gt;我是name为footer的slot&lt;&#x2F;p&gt; &lt;&#x2F;slot-two&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在父组件中使用template并写入对应的slot值来指定该内容在子组件中现实的位置（当然也不用必须写到template），没有对应值的其他内容会被放到子组件中没有添加name属性的slot中 插槽的默认值父组件 123456&lt;template&gt; &lt;div&gt; 我是父组件 &lt;slot-two&gt;&lt;&#x2F;slot-two&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 子组件 12345&lt;template&gt; &lt;div class&#x3D;&quot;slottwo&quot;&gt; &lt;slot&gt;我不是卖报的小行家&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 可以在子组件的slot标签中写入内容，当父组件没有写入内容时会显示子组件的默认内容，当父组件写入内容时，会替换子组件的默认内容. 编译作用域父组件 1234567891011121314151617&lt;template&gt; &lt;div&gt; 我是父组件 &lt;slot-two&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;slot-two&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; name： &#39;Jack&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件 12345&lt;template&gt; &lt;div class&#x3D;&quot;slottwo&quot;&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 作用域插槽专业解释：父组件应用子组件可以给插槽填充内容，但一般只填充html标签，里边的数据信息要由插槽自己提供，这个过程称为作用域插槽。个人理解：父组件在用子组件来填充插槽的时候需要用到子组件里面插槽的数据。子组件文件插槽上带的数据在父组件的子组件标签里 让一个标签 带有slot-scope=”xxx” 去接收 以便在下面进行调用。 子组件 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; 我是作用域插槽的子组件 &lt;slot :data&#x3D;&quot;user&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;slotthree&#39;, data () &#123; return &#123; user: [ &#123;name: &#39;Jack&#39;, sex: &#39;boy&#39;&#125;, &#123;name: &#39;Jone&#39;, sex: &#39;girl&#39;&#125;, &#123;name: &#39;Tom&#39;, sex: &#39;boy&#39;&#125; ] &#125; &#125;&#125;&lt;&#x2F;script&gt; 在子组件的slot标签上绑定需要的值 父组件 123456789101112&lt;template&gt; &lt;div&gt; 我是作用域插槽 &lt;slot-three&gt; &lt;template slot-scope&#x3D;&quot;user&quot;&gt; &lt;div v-for&#x3D;&quot;(item, index) in user.data&quot; :key&#x3D;&quot;index&quot;&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;slot-three&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在父组件上使用slot-scope属性，user.data就是子组件传过来的值","categories":[],"tags":[]},{"title":"CALayer","slug":"CALayer","date":"2020-05-19T03:53:28.000Z","updated":"2020-07-28T05:41:08.577Z","comments":true,"path":"2020/05/19/CALayer/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/05/19/CALayer/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"vue学习笔记","slug":"vue学习笔记","date":"2020-05-18T03:13:40.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2020/05/18/vue学习笔记/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/05/18/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"el是element的缩写； constructor 构造函数","categories":[],"tags":[]},{"title":"vue 学习计划","slug":"vue-学习计划","date":"2020-05-18T01:37:49.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2020/05/18/vue-学习计划/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/05/18/vue-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","excerpt":"","text":"基础 按照官方例子，使用&lt;script&gt;标签将官方教程（guide）写一遍，最终做个一个页面出来。（2d） 根据官方的实例，自己写一个例子，比如编辑器。（1d） 阅读官方进阶教程前半部分到自定义指令为止，着重理解vue的响应式机制和组件声明周期。『渲染函数（Render Function)』如果理解吃力可以先跳过。（1d） 阅读教程里关于路由和状态管理的章节，然后根据需要学习vue-router和vuex。根据文档中的例子跟着即可。（1d） 扩展 了解 JavaScript 背后的规范，ECMAScript 的历史和目前的规范制定方式。学习 ES2015/16 的新特性，理解 ES2015 modules，适当关注还未成为标准的提案，ES6以后是各个框架的标配，必须要学。（2d） 命令行。(0.5d) nodejs基础。(0.5d) 至少要了解 npm 的常用命令，npm scripts 如何使用，语义化版本号规则，CommonJS 模块规范（了解它和 ES2015 Modules 的异同），Node 包的解析规则，以及 Node 的常用 API。应当做到可以自己写一些基本的命令行程序。注意 Node (6+) 版本开始已经支持绝大部分 ES2015 的特性，可以借此巩固 ES2015。 了解如何使用 / 配置 Babel 来将 ES2015 编译到 ES5 用于浏览器环境。这个简单，看着Babel官网文档即可轻松配置。(0.5d) 学习 Webpack。Webpack 是一个极其强大同时也复杂的工具，作为起步，理解它的『一切皆模块』的思想，并基本了解其常用配置选项和 loader 的概念/使用方法即可，比如如何搭配 Webpack 使用 Babel。(0.5d) 学习 Webpack 的一个挑战在于其本身文档的混乱，建议多搜索搜索，应该还是有质量不错的第三方教程的。英文好的建议阅读 Webpack 2.0 的文档，比起 1.0 有极大的改善，但需要注意和 1.0 的不兼容之处。 Vue 进阶阶段 在 node 和 webpack 基础上，可以通过vue-cli来搭建基于webpack，并且支持单文件组件的项目了。建议使用webpick-simple这个模板开始，并阅读官方教程进阶篇剩余的内容以及vue-router的文档，了解一些进阶配置。可以自己亲手从零开始搭一个项目加深理解。(1d) 根据 例子 尝试在 Webpack 模板基础上整合 vue-router 和 vuex。(1d) 深入理解 Virtual DOM 和『渲染函数 (Render Functions)』这一章节（可选择性使用 JSX)，理解模板和渲染函数之间的对应关系，了解其使用方法和适用场景。(1d) 可选）根据需求，了解服务端渲染的使用（需要配合 Node 服务器开发的知识）。介绍一下服务端渲染的概念。nuxt集合了 vue-router 和 vuex、webpack的搭建套餐，有SEO需要的可以着重了解下， 并不是必须要学，这只是一种场景方案。 从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。 阅读开源的 Vue 应用、组件、插件源码，自己尝试编写开源的 Vue 组件、插件。(2d) vue各种属性和概念如何结合react 组件混合用，也有必要了解一下，它们有些方案是可以通用的，比如jsx语法、vue用redux等。(2d)","categories":[{"name":"vue","slug":"vue","permalink":"https://bianchengme.gitee.io/bianchengme/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://bianchengme.gitee.io/bianchengme/tags/vue/"},{"name":"学习计划","slug":"学习计划","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"}]},{"title":"UICollectionView","slug":"UICollectionView","date":"2020-05-13T03:38:39.000Z","updated":"2020-07-28T05:41:08.581Z","comments":true,"path":"2020/05/13/UICollectionView/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/05/13/UICollectionView/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"自定义UITabBar样式","slug":"自定义UITabBar样式","date":"2020-04-28T01:19:31.000Z","updated":"2020-07-28T05:41:08.634Z","comments":true,"path":"2020/04/28/自定义UITabBar样式/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/28/%E8%87%AA%E5%AE%9A%E4%B9%89UITabBar%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Devops","slug":"Devops","date":"2020-04-27T01:34:04.000Z","updated":"2020-07-28T05:41:08.577Z","comments":true,"path":"2020/04/27/Devops/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/27/Devops/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS Xcode, 解决“Could not insert new outlet connection”的问题","slug":"iOS-Xcode-解决“Could-not-insert-new-outlet-connection”的问题","date":"2020-04-25T08:42:54.000Z","updated":"2020-07-28T05:41:08.584Z","comments":true,"path":"2020/04/25/iOS-Xcode-解决“Could-not-insert-new-outlet-connection”的问题/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/25/iOS-Xcode-%E8%A7%A3%E5%86%B3%E2%80%9CCould-not-insert-new-outlet-connection%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"在Xcode中，我们能够在StoryBoard编辑界面或者是xib编辑界面中通过“Control键+拖拽“的方式将某个界面元素和相应的代码文件连接起来。在代码文件里创建outlet。 只是。假设你的运气不太好。运行以上操作的过程中你可能会遇到以下这种错误： Could not insert new outlet connection: Could not find any information for the class named “xxx”. 假设你遇到这种问题。拿着上面的错误消息去百度一下会发现非常多相关的内容，有各种各样的解决方法，只是效果就众说纷纭，有人说这种方法好用，有人说那个方法好用，在这里就整理一下常见的一些情况和相应的解决方法。 首先第一种情况是最简单的，也是最easy被忽略的，就是你在新建类的时候没有选择将这个类增加到相应的“Target”中。 检查方法非常easy，选中你须要操作的类的.m文件。在“File inspector”界面的“Target Membership”中确认相应的“Target”有没有选中，假设没有选中就说明你在创建类的时候犯了各小小的错误。 改动方法非常easy，直接在“File inspector”界面的“Target Membership”中选上相应的target就好了。 假设你的情况和以上不符，有可能是你的项目Derive文件有点问题，解决方法有以下几种，原理都差点儿相同，就是尝试重建项目的一些后台文件。 又一次将文件增加项目 操作步骤就是选中出问题的.m和.h文件，点删除键，然后选“Remove Reference”，这样就不会真正删除文件。 接着选“File -&gt; Add Files to …”菜单，在文件选择界面选择刚才的.m文件和.h文件将他们又一次增加项目中。 直接删除DeriveData 操作步骤是关闭当前项目，然后关闭Xcode。然后通过Terminal或者是Finder找到以下的文件夹： ~/Library/Developer/XCode/DerivedData 在里面找到以你的项目开头的文件，将他们删除。 接着又一次启动Xcode 在Organizer中删除项目的DeriveData 假设你对Mac操作系统不了解。不知道假设操作第2种解决方法，有一个更加直接的方法，就是在Xcode中选择“Windows-&gt;Organizer”，然后选择“Projects”，选中你正在处理的项目，点击“DeriveData”相应的“Delete”button，Xcode会删除该项目的DeriveData。然后自己主动又一次生成一个。","categories":[],"tags":[]},{"title":"iOS13修改status bar 的字体颜色","slug":"iOS13修改status-bar-的字体颜色","date":"2020-04-25T07:36:27.000Z","updated":"2020-07-28T05:41:08.585Z","comments":true,"path":"2020/04/25/iOS13修改status-bar-的字体颜色/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/25/iOS13%E4%BF%AE%E6%94%B9status-bar-%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/","excerpt":"","text":"StatusBarStyle定义： 1234567typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123;UIStatusBarStyleDefault &#x3D; 0, &#x2F;&#x2F; 根据用户交互样式自动选择状态条样式UIStatusBarStyleLightContent API_AVAILABLE(ios(7.0)) &#x3D; 1, &#x2F;&#x2F; Light content, for use on dark backgroundsUIStatusBarStyleDarkContent API_AVAILABLE(ios(13.0)) &#x3D; 3, &#x2F;&#x2F; Dark content, for use on light backgroundsUIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) &#x3D; 1,UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) &#x3D; 2,&#125; API_UNAVAILABLE(tvos); 定制状态条的样式 使用apple 推荐的这个系统方法: 12345678910&#x2F;&#x2F; ios 13.0 之后，这个方法已经失效了&#x2F;&#x2F; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];&#x2F;&#x2F;在UIViewController中重写方法- (UIStatusBarStyle)preferredStatusBarStyle &#123; if (@available(iOS 13.0, *))&#123; return UIStatusBarStyleDarkContent; &#125; return UIStatusBarStyleDefault;&#125; 如果你还是使用的Xcode 10 为了走过编译器这一步，可以使用预编译命令，这么写： 123456789#if defined(__IPHONE_13_0) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; __IPHONE_13_0 if (@available(iOS 13.0, *)) &#123; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDarkContent]; &#125;else&#123; [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault]; &#125;#else [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];#endif","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"}]},{"title":"git 常用命令","slug":"git-常用命令","date":"2020-04-25T01:34:59.000Z","updated":"2020-07-28T05:41:08.584Z","comments":true,"path":"2020/04/25/git-常用命令/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/25/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"提交git commit 的时候，发现一个文件无法被gitinore，猜测可能是已经提交过或者已经在git缓存里了，只有删除追踪和缓存才能被忽略。 1、先尝试取消git追踪文件 1git update-index –assume-unchanged readme1.txt &#x2F;&#x2F;清除该文件的是索引 本地的当前分支取消了追踪 本文文件不删除， 远程仓库仍是存在此文件。 本次clone的所有分支都不追踪此文件。 重新git clone后此文件仍是会被追踪。 但是不能彻底消除追踪文件，因为可能本地git缓存中有该文件。 2、删除git的缓存 1git rm --cached readme1.txt &#x2F;&#x2F;删除readme1.txt的git的缓存，并保留本地文件。 如果想本地缓存和文件一起删除 git rm --f readme1.txt 这时候再次 git status看看应该就不显示 readme1.txt了。","categories":[{"name":"git","slug":"git","permalink":"https://bianchengme.gitee.io/bianchengme/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bianchengme.gitee.io/bianchengme/tags/git/"}]},{"title":"Cocoapods CDN 错误","slug":"Cocoapods-CDN-错误","date":"2020-04-24T07:48:35.000Z","updated":"2020-07-28T05:41:08.577Z","comments":true,"path":"2020/04/24/Cocoapods-CDN-错误/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/24/Cocoapods-CDN-%E9%94%99%E8%AF%AF/","excerpt":"","text":"最近Cocoapods升级到1.8.4后，install和update都没有问题，但是search的时候就遇到了问题，问题如下： 12CDN: trunk URL couldn&#39;t be downloaded: https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CocoaPods&#x2F;Specs&#x2F;master&#x2F;Specs&#x2F;0&#x2F;a&#x2F;8&#x2F;YYModel@Haidora&#x2F;1.0.4&#x2F;YYModel@Haidora.podspec.json, error: Failed to open TCP connection to raw.githubusercontent.com:443 (Connection refused - connect(2) for &quot;raw.githubusercontent.com&quot; port 443) 解决办法比较简单，在Podfile中添加source： 123456789source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;target &#39;XXXDemo&#39; do use_frameworks! pod &#39;YYModel&#39;end 移除trunk 1pod repo remove trunk 最后为什么这样呢，很明显CDN的错误，这个问题如何解决呢，改日再找找…","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"},{"name":"Xcode","slug":"iOS/Xcode","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/Xcode/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Xcode/"}]},{"title":"Objective-C之NS_ASSUME_NONNULL_BEGIN & NS_ASSUME_NONNULL_END","slug":"Objective-C之NS-ASSUME-NONNULL-BEGIN-NS-ASSUME-NONNULL-END","date":"2020-04-24T07:46:31.000Z","updated":"2020-07-28T05:41:08.579Z","comments":true,"path":"2020/04/24/Objective-C之NS-ASSUME-NONNULL-BEGIN-NS-ASSUME-NONNULL-END/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/24/Objective-C%E4%B9%8BNS-ASSUME-NONNULL-BEGIN-NS-ASSUME-NONNULL-END/","excerpt":"","text":"NS_ASSUME_NONNULL_BEGIN &amp;&amp; NS_ASSUME_NONNULL_END在Swift中存在Option类型，也就是使用？和！声明的变量。但是OC里面没有这个特征,因为在XCODE6.3之后出现新的关键词定义用于OC转SWIFT时候可以区分到底是什么类型 nullable &amp;&amp; _nonnull__nullable指代对象可以为NULL或者为NIL__nonnull指代对象不能为null当我们不遵循这一规则时，编译器就会给出警告。 我们来看看以下的实例， 12345678910111213@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(NSString * __nonnull)name;@end@implementation TestNullabilityClass...- (void)testNullability &#123; [self itemWithName:nil]; &#x2F;&#x2F; 编译器警告：Null passed to a callee that requires a non-null argument&#125;- (id)itemWithName:(NSString * __nonnull)name &#123; return nil;&#125;@end 事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示： 1- (nullable id)itemWithName:(NSString * nonnull)name 在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明： 1@property (nonatomic, copy, nonnull) NSArray * items; 当然也可以用以下这种方式： 1@property (nonatomic, copy) NSArray * __nonnull items; 推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。 Non null区域设置(Audited Regions) 如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示： 123456NS_ASSUME_NONNULL_BEGIN@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(nullable NSString *)name;@endNS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是non null的，itemWithName:方法的返回值也是non null，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnulla。 复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用 1__nullable id * __nonnull 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。 兼容性 因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们： 老代码仍然能正常工作， 即使对nonnull对象使用了nil也没有问题。 老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。 nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。 事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。 NS_ENUM_AVAILABLE_IOS从单词的字面可以看出使用这个宏说明这个枚举开始IOS的版本 IOS版本如下 7_0 代表7.0的版本.用_替换 参数只有一个NS_ENUM_AVAILABLE_IOS(2_0) 代表&gt;=2.0开始 NS_ENUM_DEPRECATED_IOS代表枚举类型已经过时的API 第一个参数是开始的时候，第二个参数是过时的时候 NS_ENUM_DEPRECATED_IOS(2_0,7_0) 代表开始于IOS2.0废弃于IOS7.0 也就是&gt;=2.0 &lt;=7.0 __TVOS_PROHIBITED 代表这个枚举或者类，方法，参数在TVOS系统上面不能使用 1234567typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123; UIStatusBarStyleDefault = 0, // Dark content, for use on light backgrounds UIStatusBarStyleLightContent NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, \"Use UIStatusBarStyleLightContent\") = 1, UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, \"Use UIStatusBarStyleLightContent\") = 2,&#125; __TVOS_PROHIBITED; UIKIT_EXTERN extern这个是定义字符串 变量 比#define更加的高效 .但是UIKIT_EXTERN是根据是否是C语言宏定义，根据语言区分 ，比extern更加的高效 例子1UIKIT_EXTERN NSString *const UIApplicationInvalidInterfaceOrientationException NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; 上面的代码一般定义在.H 在.M实现 实现要去掉UIKIT_EXTERN.代表IOS6.0之后可以用，在TVOS系统不可用。 NS_CLASS_AVAILABLE_IOS 代表类开始的API 和上面说的类似 例子1NS_CLASS_AVAILABLE_IOS(2_0) @interface UIApplication : UIResponder NS_EXTENSION_UNAVAILABLE_IOS 标记IOS插件不能使用这些API,后面有一个参数，可以作为提示，用什么API替换 例子1+ (UIApplication *)sharedApplication NS_EXTENSION_UNAVAILABLE_IOS(\"Use view controller based solutions where appropriate instead.\"); __kindof 可以参考下面的连接 我就不多啰嗦了 Xcode 7新的特性Lightweight Generics 轻量级泛型与__kindof修饰符 NS_REQUIRES_SUPER 字面上必须继承父类的方法(有待考证) SDK_HIDE_TIDE 暂定 没查到干什么的 字面上是在SDK隐藏 NS_DESIGNATED_INITIALIZER 用来定义一些初始化方法只能过来这些标记的初始化","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"},{"name":"Objective-C","slug":"iOS/Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Objective-C/"}]},{"title":"用clang编译Objective-C对象，理解运行时机制","slug":"用clang编译Objective-C对象，理解运行时机制","date":"2020-04-19T03:26:59.000Z","updated":"2020-07-28T05:41:08.629Z","comments":true,"path":"2020/04/19/用clang编译Objective-C对象，理解运行时机制/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/19/%E7%94%A8clang%E7%BC%96%E8%AF%91Objective-C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"我们知道Objective-C的类可以通过clang编译器转换为C++的结构体，也就是说，Objective-C对象的本质就是结构体，下面通过实践来证明。 创建一个命令行项目（这里可以找到），在main.m文件添加如下的代码 1234567891011121314151617#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person: NSObject &#123; int _age; double _height;&#125;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 然后使用clang编译器重写main.m文件，可指定平台iOS和架构arm64，在main.m所在的文件夹执行如下命令 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 会得到一个main-arm64.cpp的文件，可看到Person类转换为struct Person_IMPL结构体 12345struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _age; double _height;&#125;; 存在上面定义Person类时声明的_age和_height成员变量，发现第一个成员变量是struct NSObject_IMPL结构体，这是NSObject被clang编译器重写后对应的结构体，在main-arm64.cpp文件中可找到声明 123struct NSObject_IMPL &#123; Class isa;&#125;; 实例对象（instance）Objictive-C实例对象是通过类对象创建 12Person *p1 = [Person new];Person *p2 = [[Person alloc] init]; 实例对象分配在堆空间，所以p1、p2指向的内存地址都在堆上；每次创建的都是不同的对象，所以在内存中会存在很多个实例对象。 把struct NSObject_IMPL与struct Person_IMPL合并一下得到下面的结构 12345struct Person_IMPL &#123; Class isa; int _age; double _height;&#125;; 这也是Person实例对象在内存中的布局情况。 总结一下实例对象中包含信息 isa指针，指向类对象 成员变量，其实isa也是成员变量，只不过比较特殊，它指向这个实例对象的类对象。 类对象（class）类对象是对实例对象的描述，描述这个类实例对象有哪些成员变量、属性、对象方法、类方法，那这些信息存储在什么地方呢？（下面提及的数据类型这里可以找到） 类对象声明为typedef struct objc_class *Class;，再看看struct objc_class结构体，截取一些关键的信息看看 12345678910struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; // ... 还有很多方法，略去&#125;； superclass指向父类，其他的信息存储在class_rw_t的结构体中，定义如下 1234567struct class_rw_t &#123; const class_ro_t *ro; // 实例变量信息 method_array_t methods; // 对象方法信息 property_array_t properties; // 属性信息 protocol_array_t protocols; // 协议信息 // ... 省略其他信息&#125; runtime提供这些信息函数如下 获取实例变量 12Ivar *class_copyIvarList(Class cls, unsigned int *outCount) 获取属性信息 12objc_property_t * class_copyPropertyList(Class cls, unsigned int *outCount) 获取对象方法 123// 第一个参数是 *类对象*，返回的是*对象方法*；如果是参数*元类对象*，返回的是*对象方法*Method *class_copyMethodList(Class cls, unsigned int *outCount) 获取协议信息 12Protocol * __unsafe_unretained * class_copyProtocolList(Class cls, unsigned int *outCount) struct objc_class继承objc_object，struct objc_object结构如下 12345struct objc_object &#123;private: isa_t isa; // ...省略方法&#125; 那isa_t是联合体，结构如下 12345678union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; // ...省略&#125; 这里面有个 cls成员，这个就是class指向mata-class的指针。 总结一下类对象（class）中存储的信息 isa指针，指向元类的指针 superclass指向父类的指针 成员变量（Ivar）的描述信息 属性（property）的描述信息 对象方法（Instance Method）的描述信息 遵循协议（protocol）的描述信息 元类对象（meta-class）上面可以看出，meta-class也是一个Class \\类型，与*类对象*的数据类型时一样的，只不过存储的信息不同。 元类对象（meta-class）存储的信息有 isa指针，指向基类（NSObject）元类（meta-class）的指针，所有元类（meta-class）的isa指针都指向NSObject元类的指针。 superclass指向父类的元类（meta-class）的指针 类方法（class Method）的描述信息 总结上面讲了实例对象的内存布局，以及实例对象（instance）、类对象（class）、元类对象（meta-class）之间的关系，最后用一张图来说明它们之间的关系。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Objective-C/"}]},{"title":"npm ERR! code EINTEGRITY","slug":"npm-ERR-code-EINTEGRITY","date":"2020-04-14T10:15:45.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2020/04/14/npm-ERR-code-EINTEGRITY/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/14/npm-ERR-code-EINTEGRITY/","excerpt":"","text":"在用npm安装bower sudo npm install -g bower 报错 npm ERR! code EINTEGRITY 产生的原因似乎是node源的问题，下面是我解决问题的过程。 切换为淘宝的源 12npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.orgnpm info underscore 清理缓存 12npm cache verifynpm cache clean --force 更新npm 1npm i -g npm 再次尝试安装看是否有效。","categories":[],"tags":[]},{"title":"iOS 面试题简要汇总","slug":"iOS-面试题简要汇总","date":"2020-04-12T02:13:58.000Z","updated":"2020-07-28T05:41:08.584Z","comments":true,"path":"2020/04/12/iOS-面试题简要汇总/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/12/iOS-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AE%80%E8%A6%81%E6%B1%87%E6%80%BB/","excerpt":"","text":"常见面试题的概要汇总代理为什么要用weak, delegate 和 DataSource 区别，block和delegate区别？ 防止循环引用； delegate主要是操作,dataSource主要是提供数据; block方便引用上下文，代码更容易理解，轻量级，容易造成循环引用；delegate架构设计更清晰，用weak修饰不容易造成循环引用，没有block轻量级； 属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？ 属性本质是@property = ivar + get + set,即会自动生成get/set方法； 默认关键字有atomic\\nonatomic@synthesize@dynamic\\getter=getterName\\setter=setterName\\readwrite\\readonly\\assign\\retian\\copy\\strong\\weak等; @dynamic,动态实现属性访问方法，需要再NSObject中实现 +(BOOL)resolveInstanceMethod(SEL) sel 方法中指定动态实现的函数或者方法，或者手动实现方法； @Synthesize 自动实现get、set方法； NSString为什么要用copy，如果用strong会有什么问题？ NSString指向NSMUtableString时，如果用copy，则是深copy，strong 则是指向同一个对象，有可变的隐患； 不可变字符串则是一样效果；copy在这种情况下是浅copy； copy、mutablecopy什么时候是深copy、浅copy，可变对象copy后有什么影响？ copy不可变对象浅copy，引用计数+1，copy可变对象深copy； mutablecopy全部是深copy； mutable对象copy后变不可变对象,所以NSMutableString不可用copy修饰； 不可变对象mutablecopy后变为可变对象； 对数组深copy，数组中的对应依然是浅copy;可通过initWithArray:copyItems:或者归档解档实现(对多层嵌套依然有效)； 自定义对象如果实现copy、mutablecopy？ 实现nscopying和NSMutableCopying协议； IBOutLet修饰的UIView也适用weak； 因为视图view已经对子视图有强引用了； nonatomic atomic区别；atomic是绝对的线程安全吗，如果不是如何实现； atomic 保障了get、set方法的完整性； atomic 不是绝对的线程安全，set同时其他线程可以get；如果要线程安全可以使用线程锁； UICollectionView如何实现自定义？ UICollectionViewLayoutAttributes,UICollectionFlowLayout; StoryBoard开发界面有什么弊端，如何避免； 难以维护，比如全局改动一个字体； storyBoard过大的话，加载速度慢； 遇到错误，提示不明显； 动态修改属性通过代码实现； 部分可以独立的view 可使用xib； 进程与线程、同步与异步、并行与并发还有穿行； 进程是系统内的一个运行的程序，比如一个运行的exe就是一个进程；线程是进程中的一个执行流程； 同步是顺序执行，执行完成一个在执行下个任务，需要等待，派发任务时需要任务执行完； 异步是彼此任务独立，在等待某事件的过程中继续做自己的事，不需要等待这些事件完成后再工作，派发任务不会立即执行； 并发是一个cpu多个任务复用，轮番执行任务，多个任务共享，提高效率； 并行是多个cpu同时处理多个任务； 穿行就是任务顺序执行； 线程间通信； NSThread GCD NSOperation GCD中常用函数 延迟派发dispatch_after() 一次性执行 dispatch_once() 栅栏函数 dispatch_barrier_async/dispatch_barrier_sync 队列组 dispatch_group GCD 定时器 并且更加精确 如何使用队列来避免资源抢夺？ dispatch_barrier_async,等前面队列完成后再进行操作； 数据持久化方案 coreData realm fmdb Appdelegate 方法，第一次启动调用方法，从前台到后台调用方法； 第一次调用的方法是 1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 前台到后台调用方法 12345- (void)applicationWillResignActive:(UIApplication *)application //将要进入后台- (void)applicationDidEnterBackground:(UIApplication *)application//已经进入后台- (void)applicationWillEnterForeground:(UIApplication *)application//将要进入前台 - (void)applicationDidBecomeActive:(UIApplication *)application//已经进入前台 - (void)applicationWillTerminate:(UIApplication *)application//程序结束 NSCache哪些地方优与NSDictionary 都是类似的key-value存储，不同的是nscache的key不用实现copying协议，value也不用实现coding协议； 知不知道Designated Initializer（指定初始化函数）？使用它的时候有什么需要注意的问题？12- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER; description nslog 默认是NSObject的实现，内存地址，类名等； 可以覆盖后输出关键信息，方便调试； OC使用哪种机制管理内存 returnCount机制，每次runloop的时候都要检查对象的returnCount是否小于等于0，则释放； 对比java的引用机制，通过内存回收机制遍历不可达的回收； 引用计数效率更高，但是容易出现循环引用； block实质，几种block block 结构体，有isa指针指向自己的类（global malloc stack），desc结构体描述bock，_frowording指向自己活着堆上自己的地址，截取上下文的变量，函数指针指向block代码块 block 编译的时候会生成一个函数，第一参数是block结构体指针，执行block相当于执行block里面_frowding里面的函数 static inline 是什么？ tatic inline内联函数：使用它可以减少函数运行时间，提高程序运行速度。但内联函数里不能写循环，开关语句，而且最好不写过于冗长的函数。 属性的默认关键字是什么？ 在声明property时，如果不指定关键字，编译器会为property生成默认的关键字。 对应基本数据类型，默认关键字为atomic，assign，readwrite。 对应对象类型，默认关键字为atomic，strong，readwrite。 为什么在默认情况下无法修改被block捕获的变量？__block都做了什么？ 在block中访问的外部变量是复制过去的，写操作不对原变量生效。 模拟一下循环引用的一个情况？block实现界面反向传值该怎么做？ 两个.h文件互相import了对方造成循环引用。 B反向往A传值，首先在A中声明Block 在B中添加属性，@property (nonatomic,copy) MyBlock block; 在准备接收值的A控制器里实现block，B.block = ^void(NSString *name){_label.text = name;}; 谁要传值就在B那里调用self.block(var);。 iOS事件传递响应链是什么？在我们点击屏幕的时候，iphone OS获取到了用户进行了“单击”这一行为，操作系统把包含这些点击事件的信息包装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一寻找的过程，被称作事件的响应链。不同的响应者以链式方式寻找，AppDelegate-&gt;UIApplication-&gt;UIWindow-&gt;UIViewController-&gt;UIView-&gt;UIButton 利用kvo数据绑定，在mvvm模式中，数据绑定被用的很广泛，能够动态的根据数据改变刷新UI。多线程锁strong weak assign 的区别类和结构体的区别多线程锁strong weak assign 区别oc 和 swift 混编mrc 和 arc 混编http 和 tcp 区别进程间的通信方式有哪些 URL Scheme Keychain UIPasteboard UIDocumentInteractionController Local socket AirDrop UIActivityViewController App Groups oc 对象 是结构体还是联合体多态 不同对象以自己的方式响应相同的消息的能力叫做多态。 OC中通过继承、select名字、参数等可实现；","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"flutter 0基础快速学习路线","slug":"flutter-0基础快速学习路线","date":"2020-04-08T02:57:21.000Z","updated":"2020-07-28T05:41:08.581Z","comments":true,"path":"2020/04/08/flutter-0基础快速学习路线/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/08/flutter-0%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"基础学习 搭建flutter开发环境，参考https://flutterchina.club/setup-macos/，安装默认项目到模拟器或者真机； 通读Dort语法一遍https://juejin.im/post/5c52a386f265da2de25b5c36,将文章中的语法敲一遍； 实现一个简单的HelloWorld页面，目的是熟悉Flutter的项目结构和StatelessWidget组件，通读Flutter的所有UI组件一遍：https://juejin.im/post/5c18d181f265da611f07a128，要求记住flutter的常用UI组件的继承关系； 实现页面跳转、传参、接收返回值，目的是熟悉Navigator组件； 实现一个淘宝-个人中心页面，暂不要求交互，但是页面的样式要大致实现，主要目的是熟悉基本UI组件，尤其是布局、文本、图片； 实现一个淘宝-首页，要求包含交互：下拉刷新和上拉加载更多，主要目的是熟悉复杂列表视图、滚动嵌套、手势； 实现一个简单登录页面的Http请求，服务端自己写，主要目的是熟悉Flutter的输入框、Dart的异步编程(async/await/Future)、网络请求、json解析、响应式编程(StatefulWidget/setState)； 实现一个简单登录页面的grpc请求，protobuf文件和服务端也自己写，主要目的是熟悉grpc插件的用法； 实现读取SP的简单页面，不准用第三方插件，自己用MethodChannel实现Flutter调用原生的功能； 实现Flutter项目接入宿主Android容器，主要目的是熟悉Flutter静态路由和Android原生传参给FlutterView。 进阶阶段 调研必须有输出，实践性的要有代码产出，理论性的要有wiki产出，没有产出的调研，就是耍流氓。 写一个国际化的demo，实现多语言切换； 写一个自定义View的Demo，熟悉绘图三剑客：canvas、path、paint； 写一个网络图片缓存的demo，并了解其实现原理和内存占用； 阅读源码，了解Flutter的渲染机制，如何从Widget-&gt;Element-&gt;RenderObject； 了解Dart的异步机制，深入理解async/await/Future的原理。","categories":[{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/tags/flutter/"}]},{"title":"Flutter初版","slug":"Flutter初版","date":"2020-04-03T04:42:30.000Z","updated":"2020-07-28T05:41:08.577Z","comments":true,"path":"2020/04/03/Flutter初版/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/03/Flutter%E5%88%9D%E7%89%88/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Keyboard Maestro Mac 键盘效率工具","slug":"Keyboard-Maestro-Mac-键盘效率工具","date":"2020-04-03T02:41:12.000Z","updated":"2020-07-28T05:41:08.578Z","comments":true,"path":"2020/04/03/Keyboard-Maestro-Mac-键盘效率工具/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/03/Keyboard-Maestro-Mac-%E9%94%AE%E7%9B%98%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"flutter常见错误汇总","slug":"flutter常见错误汇总","date":"2020-04-02T04:58:49.000Z","updated":"2020-07-28T05:41:08.582Z","comments":true,"path":"2020/04/02/flutter常见错误汇总/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/04/02/flutter%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB/","excerpt":"","text":"iOS真机调试证书错误 iOS真机调试中需要配置证书，现在苹果允许个人免费账号真机调试，只要要apple id就行。Flutter项目运行到iOS真机上如果没有配置证书或者原始证书配置有问题，就会报错如上图，如何修改呢，需要用到Xcode。 用Xcode打开项目，检查证书配置是否有问题: mac 10.15 运行程序提示“软件已损坏或无法验证等错误”运行如下命令: 1234567sudo spctl --master-disablexattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/libimobiledevice/idevice_idxattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/libimobiledevice/idevicenamexattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/libimobiledevice/idevicescreenshotxattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/libimobiledevice/idevicesyslogxattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/libimobiledevice/ideviceinfoxattr -r -d com.apple.quarantine ~/development/flutter/bin/cache/artifacts/usbmuxd/iproxy 如果还有其它软件还有如此提示可以参考上面命令，另外第一个命令其实修改了软件修改条件，在设置-&gt;安全中可以看到,如果担心安全问题可以修改回去，下次需要再设置。 Android Studio 运行后无法热加载错误提示如下： 1Error connecting to the service protocol: failed to connect to http://127.0.0.1 一般是设备版本的问题，建议换个设备或者模拟器试试。","categories":[{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/tags/flutter/"},{"name":"BUG","slug":"BUG","permalink":"https://bianchengme.gitee.io/bianchengme/tags/BUG/"},{"name":"iOS真机运行","slug":"iOS真机运行","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C/"}]},{"title":"iOS开发之fishhook","slug":"iOS开发之fishhook","date":"2020-03-31T13:34:41.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2020/03/31/iOS开发之fishhook/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/03/31/iOS%E5%BC%80%E5%8F%91%E4%B9%8Bfishhook/","excerpt":"","text":"HOOK之Method Swizzlemethod_exchangeImplementations利用OC的Runtime特性，动态改变SEL（方法编号）和IMP（方法实现）的对应关系，达到OC方法调用流程改变的目的。主要用于OC方法。 12345#import &lt;objc/message.h&gt;//实现 Method old = class_getInstanceMethod(class, oldMethod); Method news = class_getInstanceMethod(class, newMethod); method_exchangeImplementations(old, news); HOOK之 fishhookFacebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，原理是通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的,所以不能修改自己定义的函数，只能修改系统库函数。 ####demo 1234567891011121314151617181920212223242526272829303132333435363738#import \"fishhook.h\"- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"123\"); //定义rebinding结构体/*struct rebinding &#123; const char *name;//需要HOOK的函数名称,字符串 void *replacement;//替换到那个新的函数上(函数指针,也就是函数的名称) void **replaced;//保存原始函数指针变量的指针(它是一个二级指针!)&#125;;*/ struct rebinding nslogBind; //函数的名称 nslogBind.name = \"NSLog\"; //新的函数地址 nslogBind.replacement = myNSLog; //保存原始函数地址的变量的指针 nslogBind.replaced = (void *)&amp;old_nslog; //定义数组 struct rebinding rebs[] = &#123;nslogBind&#125;; /* arg1 : 存放rebinding结构体的数组 arg2 : 数组的长度 */ rebind_symbols(rebs, 1);&#125;//函数指针,用保存原始的函数的地址static void (*old_nslog)(NSString *format, ...);//新的NSLogvoid myNSLog(NSString *format, ...)&#123; format = [format stringByAppendingString:@\"\\n勾上了!\"]; //再调用原来的 old_nslog(format); &#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"点击了屏幕!!\"); &#125; ###原理 APP运行时，MachO被dyld加载进内存 ASLR让MachO被加载时内存地址随机分配 苹果的PIC位置与代码独立技术，让MachO调用系统库函数时，先在MachO表中的_DATA段建立一个指针指向外部库函数，dyld加载MachO时知道外部库函数的调用地址，会动态的把_DATA段的指针指向外部库函数 fishhook通过nslogBind.name = “NSLog” 就能替换库函数，是因为MachO的符号表里有NSLog等，可以通过符号表找到NSLog字符串 ###使用fishhook基本防护OC的Runtime特性，替换执行的方法，要用到系统方法method_exchangeImplementations、 method_getImplementation、method_setImplementation等，就可以用fishhook动态替换这些系统方法，方式HOOK。 1234567891011121314151617181920212223242526272829303132333435363738#import \"fishhook.h\"#import &lt;objc/message.h&gt;@implementation hookMgr//专门HOOK+(void)load&#123; //基本防护 会检测到外部的hook struct rebinding exchangebinding; exchangebinding.name = \"method_exchangeImplementations\"; exchangebinding.replacement = myExchange; exchangebinding.replaced = (void *)&amp;exchangeP; struct rebinding getIMPbinding; getIMPbinding.name = \"method_getImplementation\"; getIMPbinding.replacement = myExchange; getIMPbinding.replaced = (void *)&amp;getIMP; struct rebinding setIMPbinding; setIMPbinding.name = \"method_setImplementation\"; setIMPbinding.replacement = myExchange; setIMPbinding.replaced = (void *)&amp;setIMP; struct rebinding rebs[] = &#123;exchangebinding,getIMPbinding,setIMPbinding&#125;; rebind_symbols(rebs, 3);&#125;//保留原来的交换函数static void (*exchangeP)(Method _Nonnull m1, Method _Nonnull m2);IMP _Nonnull (*setIMP)(Method _Nonnull m, IMP _Nonnull imp);IMP _Nonnull (*getIMP)(Method _Nonnull m);//新的函数void myExchange(Method _Nonnull m1, Method _Nonnull m2)&#123; NSLog(@\"外部hook 不给过\"); //这里可以做些让程序崩溃的事情 exit(0);//闪退，只要发现你hook我，我就闪退&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"hook","slug":"hook","permalink":"https://bianchengme.gitee.io/bianchengme/tags/hook/"}]},{"title":"iOS开发之Runloop","slug":"iOS开发之Runloop","date":"2020-03-31T09:14:31.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2020/03/31/iOS开发之Runloop/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/03/31/iOS%E5%BC%80%E5%8F%91%E4%B9%8BRunloop/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS多线程","slug":"iOS多线程","date":"2020-03-28T04:15:14.000Z","updated":"2020-07-28T05:41:08.585Z","comments":true,"path":"2020/03/28/iOS多线程/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2020/03/28/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"在开发工作中，多线程的使用还是很频繁的，不过对多线程的总结以及多线程的原理的探究一直没有做过。 使用场景 多线程的使用场景一般都是耗时操作，如API请求、加载网络图片、视频、歌曲等资源，另外还有一些延时操作。抽象的说就是充分发挥多核处理器的优势,并发(同时执行) 执行任务让系统运行的更快、更流畅。 基本概念进程 进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元. 进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app. 每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源 线程 程序执行流的最小单元，线程是进程中的一个实体. 一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程 进程和线程的关系 线程是进程的执行单元，进程的所有任务都在线程中执行 线程是 CPU 分配资源和调度的最小单位 一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程 同一个进程内的线程共享进程资源 多线程同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象； 优势 充分发挥多核处理器的优势，将不同的任务分配给不同的处理器，真正进行“并行运算”状态； 将耗时、轮询或者并发需求高的任务分配到其它线程执行，并有主线程统一更新界面，会是应用程序更加流畅，用户体验更好； 当硬件处理器数量的增加，程序运行更快，而无需做任何调整； 难点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 任务和队列实际开发中直接创建线程使用比较复杂，复杂情况通常通过队列派发任务方式实现多线程任务调度更便捷、高效。 任务就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：同步执行（sync）和异步执行（async） 同步(Sync)：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。 异步(Async)：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务 队列队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。 串行队列（Serial Dispatch Queue）：同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的 并发队列（Concurrent Dispatch Queue）：同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效 iOS 多线程实现主要有三种：NSThread、NSoperationQueue、GCD NSThread：轻量级别的多线程技术是我们自己手动开辟的子线程，如果使用的是初始化方式就需要我们自己启动，如果使用的是构造器方式它就会自动启动。只要是我们手动开辟的线程，都需要我们自己管理该线程，不只是启动，还有该线程使用完毕后的资源回收","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"iOS开发Objective-C总结","slug":"iOS开发Objective-C总结","date":"2019-06-05T02:41:26.000Z","updated":"2020-07-28T05:41:08.586Z","comments":true,"path":"2019/06/05/iOS开发Objective-C总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/06/05/iOS%E5%BC%80%E5%8F%91Objective-C%E6%80%BB%E7%BB%93/","excerpt":"","text":"Objective_C语言特性：分类、扩展、代理、通知、KVO、KVC、属性分类（category）扩展（Extension）代理（Delegate）通知（NSNotification)KVO (Key-value observing)KVC (Key-value coding)属性关键字 一、分类1.分类的作用？声明私有方法，分解体积大的类文件，把framework的私有方法公开（官方不推荐） 2.分类的特点运行时决议，可以为系统类添加分类 。说得详细些，在运行时时期，将 Category 中的实例方法列表、协议列表、属性列表添加到主类中后（所以Category中的方法在方法列表中的位置是在主类的同名方法之前的），然后会递归调用所有类的 load 方法，这一切都是在main函数之前执行的。 3.分类可以添加哪些内容？实例方法，类方法，协议，属性（添加getter和setter方法，并没有实例变量，添加实例变量需要用关联对象） 4.如果工程里有两个分类A和B，两个分类中有一个同名的方法，哪个方法最终生效？取决于分类的编译顺序，最后编译的那个分类的同名方法最终生效，而之前的都会被覆盖掉(这里并不是真正的覆盖，因为其余方法仍然存在，只是访问不到，因为在动态添加类的方法的时候是倒序遍历方法列表的，而最后编译的分类的方法会放在方法列表前面，访问的时候就会先被访问到，同理如果声明了一个和原类方法同名的方法，也会覆盖掉原类的方法)。 5.如果声明了两个同名的分类会怎样？会报错，所以第三方的分类，一般都带有命名前缀 6.分类能添加成员变量吗？不能。只能通过关联对象(objc_setAssociatedObject)来模拟实现成员变量，但其实质是关联内容，所有对象的关联内容都放在同一个全局容器哈希表中:AssociationsHashMap,由AssociationsManager统一管理。 二、扩展1.一般用扩展做什么？声明私有属性，声明方法（没什么意义），声明私有成员变量 2.扩展的特点编译时决议，只能以声明的形式存在，多数情况下寄生在宿主类的.m中，不能为系统类添加扩展。 三、代理（Delegate）代理是一种设计模式，以@protocol形式体现，一般是一对一传递。一般以weak关键词以规避循环引用。 四、通知（NSNotification）使用观察者模式来实现的用于跨层传递信息的机制。传递方式是一对多的。 如果实现通知机制？ ##五、KVO (Key-value observing)KVO是观察者模式的另一实现。使用了isa混写(isa-swizzling)来实现KVO 使用setter方法改变值KVO会生效，使用setValue:forKey即KVC改变值KVO也会生效，因为KVC会去调用setter方法 12345678- (void)setValue:(id)value&#123; [self willChangeValueForKey:@&quot;key&quot;]; [super setValue:value]; [self didChangeValueForKey:@&quot;key&quot;];&#125; 那么通过直接赋值成员变量会触发KVO吗？不会，因为不会调用setter方法，需要加上willChangeValueForKey和didChangeValueForKey方法来手动触发才行 六、KVC(Key-value coding)12-(id)valueForKey:(NSString *)key;-(void)setValue:(id)value forKey:(NSString *)key; KVC就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的. 当调用setValue：属性值 forKey：@”name“的代码时，，底层的执行机制如下： 程序优先调用set:属性值方法，代码通过setter方法完成设置。注意，这里的是指成员变量名，首字母大小写要符合KVC的命名规则，下同 如果没有找到setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUndefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以命名的变量，KVC都可以对该成员变量赋值。 如果该类即没有set：方法，也没有_成员变量，KVC机制会搜索_is的成员变量。 和上面一样，如果该类即没有set：方法，也没有_和_is成员变量，KVC机制再会继续搜索和is的成员变量。再给它们赋值。 如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey：方法，默认是抛出异常。 即如果没有找到Set方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员并进行赋值操作。如果开发者想让这个类禁用KVC，那么重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到set:属性名时，会直接用setValue：forUndefinedKey：方法。 当调用valueForKey：@”name“的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，其搜索方式如下： 首先按get,,is的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。 如果上面的getter没有找到，KVC则会查找countOf,objectInAtIndex或AtIndexes格式的方法。如果countOf方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf,objectInAtIndex或AtIndexes这几个方法组合的形式调用。还有一个可选的get:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。 如果上面的方法没有找到，那么会同时查找countOf，enumeratorOf,memberOf格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf，enumeratorOf,memberOf组合的形式调用。 如果还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_,_is,,is的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法+ (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey:方法，默认是抛出异常。 七、属性关键字 读写权限：readonly,readwrite(默认) 原子性: atomic(默认)，nonatomic。atomic读写线程安全，但效率低，而且不是绝对的安全，比如如果修饰的是数组，那么对数组的读写是安全的，但如果是操作数组进行添加移除其中对象的还，就不保证安全了。 引用计数： retain/strong assign：修饰基本数据类型，修饰对象类型时，不改变其引用计数，会产生悬垂指针，修饰的对象在被释放后，assign指针仍然指向原对象内存地址，如果使用assign指针继续访问原对象的话，就可能会导致内存泄漏或程序异常 weak：不改变被修饰对象的引用计数，所指对象在被释放后，weak指针会自动置为nil copy：分为深拷贝和浅拷贝 浅拷贝：对内存地址的复制，让目标对象指针和原对象指向同一片内存空间会增加引用计数 深拷贝：对对象内容的复制，开辟新的内存空间 可变对象的copy和mutableCopy都是深拷贝不可变对象的copy是浅拷贝，mutableCopy是深拷贝copy方法返回的都是不可变对象 - @property (nonatomic, copy) NSMutableArray * array;这样写有什么影响？ 因为copy方法返回的都是不可变对象，所以array对象实际上是不可变的，如果对其进行可变操作如添加移除对象，则会造成程序crash","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Objective-C/"}]},{"title":"iOS开发Swift总结","slug":"iOS开发Swift总结","date":"2019-05-27T08:58:11.000Z","updated":"2020-07-28T05:41:08.593Z","comments":true,"path":"2019/05/27/iOS开发Swift总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/05/27/iOS%E5%BC%80%E5%8F%91Swift%E6%80%BB%E7%BB%93/","excerpt":"","text":"Safe &amp; Fast1、能用let，尽量别用var。~ 把代码中的var都改成let，只保留编译不能通过的。 ~ Object-C的Foundation层，都是继承NSObject实现的，平时都在操作指针，所以要区分Mutable和imutable，比如NSString和NSMutableString。Swift使用let和var关键字用于用于区分是否可变。可变会更容易出错，所以尽可能使用比可变设计，等到需要改变再改成var。 2.尽量不用“!”“!”遇到nil时，会crash(包括 as!进行强制转换)。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Swift/"}]},{"title":"iOS开发中使用Block总结","slug":"iOS开发中使用Block总结","date":"2019-04-06T02:36:17.000Z","updated":"2020-07-28T05:41:08.609Z","comments":true,"path":"2019/04/06/iOS开发中使用Block总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/04/06/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8Block%E6%80%BB%E7%BB%93/","excerpt":"","text":"###Block的本质 将 “函数” 及 “执行其上下文” 封装起来的 “对象” block的调用就是函数的调用 1234567int main(int argc, const char * argv[]) &#123; int (^add)(int a,int b) = ^(int a,int b)&#123; return a + b; &#125;; NSLog(@\"%d\",add(10,20)); return 0;&#125; 使用 “clang -rewrite-objc main.m”查看编译之后的部分内容 __block_impl 结构体中发现有 isa 指针，所以说block是Objective-C对象 ###block捕获变量特性 在block中使用外部变量时，block会捕获其变量，具体规则如下 局部变量为基本数据类型：捕获其值 局部变量为对象类型：连同所有权修饰符一起捕获 局部变量为静态的：以指针的形式捕获 全局变量：不捕获 全局静态变量：不捕获 123456789101112131415161718int testGlobalVar = 0;static int testGlobalStaticVar = 0;int main(int argc, const char * argv[]) &#123; int testVar = 0; __strong id obj = [[NSObject alloc]init]; static int testStaticVar = 0; void(^test)(void) = ^()&#123; NSLog(@\"局部变量为基本数据类型%d\",testVar); NSLog(@\"局部变量为对象类型%@\",obj); NSLog(@\"局部变量为静态的%d\",testStaticVar); NSLog(@\"全局变量%d\",testGlobalVar); NSLog(@\"全局静态变量%d\",testGlobalStaticVar); &#125;; test(); return 0;&#125; 编译后看到效果 将上述代码编译后，我们再看main_block_impl_0结构体中这几个变量在其中的类型，就可以更好理解block的捕获特性，strong为默认修饰符，所有编译后无效果。 由于捕获的特性，当我们在block中使用对象类型时，需要注意循环引用 __block 使用场景：在blcok内部对捕获的值进行赋值 局部变量为基本数据类型、对象类型，需要__block 静态局部变量、全局变量、全局静态变量，不需要__block，因为静态局部变量不捕获其指针，全局变量、全局静态变量不捕获 如图，编译后的文件，我们发现，局部数据类型变量a、局部对象类型obj竟然变成了结构体实例 Block_byref_a_0结构体实例的成员变量forwarding持有指向该实例自身的指针 ###Block内存管理 类 对应对象的存储域 _NSConcreteStackBlock 栈 _NSConcreteGlobalBlock 数据区域(.data区) _NSConcreteMallocBlock 堆 通过几个栗子来分析内存管理： 栗子1：block不捕获任何外部变量，分配在全局区 栗子2：block捕获局部变量，分配在堆区栗子3：block捕获局部静态变量，分配在全局区栗子4：block捕获全局变量，分配在全局区栗子5：block捕获全局静态变量，分配在全局区5个栗子，blcok不是分配在堆区，就是分配在全局区，什么时候分配在栈区呢？ 截取官方文档的一个图，可以发现，当发送copy消息的时候，会将block分配在堆区，但是我们并没有发任何copy消息呀，why？因为系统已经偷偷给我们发送了copy消息怎么不让系统帮我们呢？栗子6：__weak 修饰block 用好类型别名为常用的 block 类型创建 typedef用 typedef 重新定义block类型，可以使 block 变量用起来更加简单 123456789typedef int(^Add)(int a,int b);int main(int argc, const char * argv[]) &#123; Add add = ^(int a,int b)&#123; return a + b; &#125;; NSLog(@\"%d\",add(10,20)); return 0;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"}]},{"title":"iOS开发UI总结","slug":"iOS开发UI总结","date":"2019-03-29T02:42:19.000Z","updated":"2020-07-28T05:41:08.593Z","comments":true,"path":"2019/03/29/iOS开发UI总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91UI%E6%80%BB%E7%BB%93/","excerpt":"","text":"UI相关的几个要点 UIView &amp; CALayer 事件传递和视图响应链 图像显示原理 UI卡顿掉帧原理 滑动优化方案 离屏渲染 UIView &amp; CALayerUIView不用介绍，CALayer类在概念上和UIView类似，每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews。但是 Layer 比 View 多了个AnchorPoint。UIView可以通过CALayer可以实现 阴影，圆角，带颜色的边框、3D变换、非矩形规范、透明遮照、多级非线性动画等。 他们的区别是： 与UIView最大的不同就是CALyer不处理用户的交互,不清楚具体的响应链； 二者并无继承关系，CALyer是UIView显示内容的内部实现； UIView是对CALayer的一个封装，并提供了一些显示控制和响应链的功能； 这样的设计体现了单一职责原则：UIView为CALayer提供内容，以及负责处理触摸等事件，参与响应链；CALayer负责显示内容contents。 ##事件传递 &amp; 视图响应链 两个UIView方法: 1234&#x2F;&#x2F;空间是否响事件测试- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;&#x2F;&#x2F;判断点位位置是否在区域内- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; 事件传递顺序 通过代码体现 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; 此方法就是寻找最为合适的响应的控件 override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123; super.hitTest(point, with: event); &#x2F;&#x2F; 1 UIView不接收触摸事件的三种情况： if self.isUserInteractionEnabled &#x3D;&#x3D; false || self.alpha &lt;&#x3D; 0.1 || self.isHidden &#x3D;&#x3D; true &#123; return nil; &#125; &#x2F;&#x2F; 2 判断当前的点是否在此控件上面 if self.point(inside: point, with: event) &#x3D;&#x3D; false &#123; return nil; &#125; &#x2F;&#x2F; 3 以上条件都满足 去遍历自己的子空间 for view in self.subviews &#123; &#x2F;&#x2F; 转为目标控件的点 let current_point &#x3D; self.convert(point, to: view); &#x2F;&#x2F; 让子视图再去遍历 如果有的话 进行返回操作 没有的话 不要紧 返回nil就好了 if view.hitTest(current_point, with: event) !&#x3D; nil &#123; return view; &#125; &#125; &#x2F;&#x2F; 4 如果以上都没有找到 那就返回自己 return self; &#125; 调用逻辑 图像显示原理cpu和GPU关系 1.CPU:输出位图2.GPU :图层渲染，纹理合成3.把结果放到帧缓冲区(frame buffer)中4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容5.显示到屏幕上 cpu和gpu的显示中的分工 CPU工作1.Layout: UI布局，文本计算2.Display: 绘制3.Prepare: 图片解码4.Commit：提交位图 GPU渲染管线(OpenGL)顶点着色，图元装配，光栅化，片段着色，片段处理 ##UI卡顿掉帧的原因 iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。 一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。 ##滑动优化方案CPU：把以下操作放在子线程中1.对象创建、调整、销毁2.预排版（布局计算、文本计算、缓存高度等等）3.预渲染（文本等异步绘制，图片解码等） GPU:纹理渲染，视图混合 一般遇到性能问题时，考虑以下问题：是否受到CPU或者GPU的限制？是否有不必要的CPU渲染？是否有太多的离屏渲染操作？是否有太多的图层混合操作？是否有奇怪的图片格式或者尺寸？是否涉及到昂贵的view或者效果？view的层次结构是否合理？ UI绘制原理 异步绘制：[self.layer.delegate displayLayer: ]代理负责生成对应的bitmap,设置该bitmap作为该layer.contents属性的值 离屏渲染On-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作应当尽量避免的则是GPU离屏渲染 GPU离屏渲染何时会触发呢？圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置 1layer.shouldRasterize ＝ YES 为什么要避免GPU离屏渲染？ GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"https://bianchengme.gitee.io/bianchengme/tags/UI/"}]},{"title":"iOS开发中RunTime总结","slug":"iOS开发中RunTime总结","date":"2019-03-29T02:39:12.000Z","updated":"2020-07-28T05:41:08.602Z","comments":true,"path":"2019/03/29/iOS开发中RunTime总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91%E4%B8%ADRunTime%E6%80%BB%E7%BB%93/","excerpt":"","text":"#runtime相关 数据结构：NSObject、objc_object、objc_class、isa、class_data_bits_t\u0010\u0010、cache_t、method_t 对象、类对象、元类对象 消息传递、消息转发 一、数据结构：NSObject、objc_object、objc_class、isa、class_data_bits_t\u0010\u0010、cache_t、method_t NSObject在OC中，基本上所有的类的基类，都是NSObject。因此要深入了解OC中的类的结构，就要从NSObject这个类说起。 123@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; NSObject仅有一个实例变量Class isa： 12&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.typedef struct objc_class *Class; Class实质上是指向objc_class的指针。而objc_class的定义： 1234567891011121314struct objc_class : objc_object &#123; &#x2F;&#x2F; Class ISA; Class superclass; cache_t cache; &#x2F;&#x2F; formerly cache pointer and vtable class_data_bits_t bits; &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags class_rw_t *data() &#123; return bits.data(); &#125; void setData(class_rw_t *newData) &#123; bits.setData(newData); &#125; 。。。&#125; 可以看到，objc_class继承自objc_object；在objc_class中，有三个数据成员：superclass 、cache、bits。 Class superclass ：同样是Class类型，表明当前类的父类。 cache_t cache ：用于快速查找方法执行函数，可增量扩展的哈希表结构，是局部性原理的最佳运用。 12345678910struct cache_t &#123; struct bucket_t *_buckets;&#x2F;&#x2F;一个散列表，用来方法缓存，bucket_t类型，包含key以及方法实现IMP mask_t _mask;&#x2F;&#x2F;分配用来缓存bucket的总数 mask_t _occupied;&#x2F;&#x2F;表明目前实际占用的缓存bucket的个数｝struct bucket_t &#123; private: cache_key_t _key; IMP _imp; ｝ runtime当要调用一个方法时，先不去Class的方法列表中查找，而是先去找cache_t cache 。当系统调用过一个方法后，会将其实现IMP和key存放到cache中，因为理论上一个方法调用过后，被再次调用的概率很大。 class_data_bits_t bits：这是Class的核心，其本质是一个可以被Mask的指针类型。根据不同的Mask，可以取出不同的值。可以看做对class_rw_t的封装。 1234567891011121314151617181920struct class_data_bits_t &#123; &#x2F;&#x2F; Values are the FAST_ flags above. uintptr_t bits; public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125; void setData(class_rw_t *newData) &#123; assert(!data() || (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE))); &#x2F;&#x2F; Set during realization or construction only. No locking needed. &#x2F;&#x2F; Use a store-release fence because there may be concurrent &#x2F;&#x2F; readers of data and data&#39;s contents. uintptr_t newBits &#x3D; (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData; atomic_thread_fence(memory_order_release); bits &#x3D; newBits; &#125; 。。。 class_data_bits_t bits 仅含有一个成员uintptr_t bits， 可以理解为一个‘复合指针’。什么意思呢，就是bits不仅包含了指针，同时包含了Class的各种异或flag，来说明Class的属性。把这些信息复合在一起，仅用一个uint指针bits来表示。当需要取出这些信息时，需要用对应的以FAST_ 前缀开头的flag掩码对bits做按位与操作。 例如，我们需要取出Classs的核心信息class_rw_t, 则需要调用方法： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125; class_rw_t：Class的核心结构 123456789101112131415struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;｝ Objc的类的属性、方法、以及遵循的协议都放在class_rw_t中，class_rw_t代表了类相关的读写信息，是对class_ro_t的封装，而class_ro_t代表了类的只读信息，存储了 编译器决定了的属性、方法和遵守协议 12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125; &#125;; objc_object（id） OC的底层实现是runtime，在runtime这一层，对象被定义为objc_object 结构体，类被定义为了objc_class 结构体。而objc_class 继承于objc_object， 因此，类可以看做是一类特殊的对象。 123456789101112131415struct objc_object &#123;private: isa_t isa;public: &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object Class ISA(); &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object Class getIsa(); &#x2F;&#x2F; 省略其余方法 ...&#125; objc_object的定义很简单，仅包含一个isa_t类型 isa,有关于isa操作相关，弱引用相关，关联对象相关，内存关联相关。 isa指针，共用体isa_t isa关于对象，其指向类对象。关于类对象，其指向元类对象。实例-(isa)-&gt;class-(isa)-&gt;MetaClass 1234567891011union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; &#x2F;&#x2F; 省略其余 。。。&#125; method_t 函数四要素：名称、返回值、参数、函数体 12345struct method_t &#123; SEL name; &#x2F;&#x2F;名称 const char *types;&#x2F;&#x2F;返回值和参数 IMP imp; &#x2F;&#x2F;函数体｝ 二、对象、类对象、元类对象 类对象存储实例方法列表等信息； 元类对象存储类方法列表等信息； superClass是一层层集成的，到最后NSObject的superClass是nil。而NSObject的isa指向根元类，这个根元类的isa指向他自己，而他的superClass是NSObject，也就是最后形成一个环。 三、消息传递1234567891011121314151617void objc_msgSend(void &#x2F;* id self, SEL op, ... *&#x2F; )void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )struct objc_super &#123; &#x2F;&#x2F;&#x2F; Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ &#x2F;* For compatibility with old objc-runtime.h header *&#x2F; __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif &#x2F;* super_class is the first class to search *&#x2F;&#125;; 消息传递的流程：缓存查找–&gt;当前类查找–&gt;父类逐级查找 调用方法之前，先去查找缓存，看看缓存中是否有对应选择器的方法实现，如果有，就去调用函数，完成消息传递（缓存查找：给定值SEL,目标是查找对应bucket_t中的IMP，哈希查找） 如果缓存中没有，会根据当前实例的isa指针查找当前类对象的方法列表，看看是否有同样名称的方法 ，如果找到，就去调用函数，完成消息传递（当前类中查找：对于已排序好的方法列表，采用二分查找，对于没有排序好的列表，采用一般遍历） 如果当前类对象的方法列表没有，就会逐级父类方法列表中查找，如果找到，就去调用函数，完成消息传递（父类逐级查找：先判断父类是否为nil，为nil则结束，否则就继续进行缓存查找–&gt;当前类查找–&gt;父类逐级查找的流程） 如果一直查到根类依然没有查找到，则进入到消息转发流程中，完成消息传递 四、消息转发12345+ (BOOL)resolveInstanceMethod:(SEL)sel;&#x2F;&#x2F;为对象方法进行决议+ (BOOL)resolveClassMethod:(SEL)sel;&#x2F;&#x2F;为类方法进行决议- (id)forwardingTargetForSelector:(SEL)aSelector;&#x2F;&#x2F;方法转发目标- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;- (void)forwardInvocation:(NSInvocation *)anInvocation; 那么最后消息未能处理的时候，还会调用到 (void)doesNotRecognizeSelector:(SEL)aSelector这个方法，我们也可以在这个方法中做处理，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来 方法交换(Method-Swizzling) 12345678 + (void)load&#123; Method test &#x3D; class_getInstanceMethod(self, @selector(test)); Method otherTest &#x3D; class_getInstanceMethod(self, @selector(otherTest)); method_exchangeImplementations(test, otherTest);&#125; 应用场景：替换系统的方法，比如viewDidLoad，viewWillAppear以及一些响应方法，来进行统计信息 动态添加方法 123456class_addMethod(self, sel, testImp, &quot;v@:&quot;);void testImp (void)&#123; NSLog(@&quot;testImp&quot;);&#125; @dynamic 动态方法解析 动态运行时语言将函数决议推迟到运行时编译时语言在编译期进行函数决议 [obj foo]和objc_msgSend()函数之间有什么关系？ objc_msgSend()是[obj foo]的具体实现。在runtime中，objc_msgSend()是一个c函数，[obj foo]会被翻译成这样的形式objc_msgSend(obj, foo)。 runtime是如何通过selector找到对应的IMP地址的？ 缓存查找–&gt;当前类查找–&gt;父类逐级查找 能否向编译后的类中增加实例变量？ 不能。 编译后，该类已经完成了实例变量的布局，不能再增加实例变量。但可以向动态添加的类中增加实例变量。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"RunTime","slug":"RunTime","permalink":"https://bianchengme.gitee.io/bianchengme/tags/RunTime/"}]},{"title":"iOS开发中内存管理总结","slug":"iOS开发中内存管理总结","date":"2019-03-29T02:38:26.000Z","updated":"2020-07-28T05:41:08.627Z","comments":true,"path":"2019/03/29/iOS开发中内存管理总结/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/29/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"}]},{"title":"iOS网络编程","slug":"iOS网络编程","date":"2019-03-15T02:31:45.000Z","updated":"2020-07-28T05:41:08.628Z","comments":true,"path":"2019/03/15/iOS网络编程/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/15/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"网络","slug":"网络","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"iOS常见算法汇总","slug":"iOS常见算法汇总","date":"2019-03-05T02:28:42.000Z","updated":"2020-07-28T05:41:08.586Z","comments":true,"path":"2019/03/05/iOS常见算法汇总/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/05/iOS%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/","excerpt":"","text":"算法相关 字符串反转 链表反转 有序数组合并 Hash算法 查找两个子视图的共同父视图 求无序数组当中的中位数 github地址 1.字符串反转给定字符串 “Hello,world”实现将其反转。输出“dlrow,olleh”。 思路：字符串数组中从开始收尾交换，一直到中间元素，实现数组反转； 12345678910char ch[] = \"hello,world\";char *begin = ch;char *end = ch + strlen(ch) - 1;while (begin &lt; end) &#123; char temp = *begin; *(begin++) = *end; *(end--) = temp;&#125;printf(\"reverseString:%s\\n\", ch); 2.链表反转反转前1-&gt;2-&gt;3-&gt;4-&gt;NULL反转后4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路：因为链表是从头到尾遍历，想要反转，最方便的就是构造链表从尾部到头部的顺序构造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** 定义一个链表 */struct Node &#123; NSInteger data; struct Node * next;&#125;;- (void)listReverse&#123; struct Node * p = [self constructList]; [self printList:p]; //反转后的链表头部 struct Node * newH = NULL; //头插法 while (p != NULL) &#123; //记录下一个结点 struct Node * temp = p-&gt;next; //当前结点的next指向新链表的头部 p-&gt;next = newH; //更改新链表头部为当前结点 newH = p; //移动p到下一个结点 p = temp; &#125; [self printList:newH];&#125;/** 打印链表 @param head 给定链表 */- (void)printList:(struct Node *)head&#123; struct Node * temp = head; printf(\"list is : \"); while (temp != NULL) &#123; printf(\"%zd \",temp-&gt;data); temp = temp-&gt;next; &#125; printf(\"\\n\");&#125;/** 构造链表 */- (struct Node *)constructList&#123; //头结点 struct Node *head = NULL; //尾结点 struct Node *cur = NULL; for (NSInteger i = 0; i &lt; 10; i++) &#123; struct Node *node = malloc(sizeof(struct Node)); node-&gt;data = i; //头结点为空，新结点即为头结点 if (head == NULL) &#123; head = node; &#125;else&#123; //当前结点的next为尾结点 cur-&gt;next = node; &#125; //设置当前结点为新结点 cur = node; &#125; return head;&#125; 3.有序数组合并将有序数组 和 合并为 思路：两个数组一起遍历，选择合适的（比较小的）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)orderListMerge&#123; int aLen = 5,bLen = 9; int a[] = &#123;1,4,6,7,9&#125;; int b[] = &#123;2,3,5,6,8,9,10,11,12&#125;; [self printList:a length:aLen]; [self printList:b length:bLen]; int result[14]; int p = 0,q = 0,i = 0;//p和q分别为a和b的下标，i为合并结果数组的下标 //任一数组没有达到s边界则进行遍历 while (p &lt; aLen &amp;&amp; q &lt; bLen) &#123; //如果a数组对应位置的值小于b数组对应位置的值,则存储a数组的值，并移动a数组的下标与合并结果数组的下标 if (a[p] &lt; b[q]) result[i++] = a[p++]; //否则存储b数组的值，并移动b数组的下标与合并结果数组的下标 else result[i++] = b[q++]; &#125; //如果a数组有剩余，将a数组剩余部分拼接到合并结果数组的后面 while (++p &lt; aLen) &#123; result[i++] = a[p]; &#125; //如果b数组有剩余，将b数组剩余部分拼接到合并结果数组的后面 while (q &lt; bLen) &#123; result[i++] = b[q++]; &#125; [self printList:result length:aLen + bLen];&#125;- (void)printList:(int [])list length:(int)length&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d \",list[i]); &#125; printf(\"\\n\");&#125; 4.HASH算法 哈希表 在一个字符串中找到第一个只出现一次的字符。如输入“fsfsbcd”,输出”b”; 思路：字符（char）是一个长度为8的数据类型，因此总共有256中可能。每个字母根据其ASC||码值作为组数下标对应数组中的一个数字。数组中存储每次字符出现的次数。 12345678910111213141516171819202122232425262728293031323334353637383940- (void)hashTest&#123; NSString * testString = @\"hhaabccdeef\"; char testCh[100]; memcpy(testCh, [testString cStringUsingEncoding:NSUTF8StringEncoding], [testString length]); int list[256]; for (int i = 0; i &lt; 256; i++) &#123; list[i] = 0; &#125; char *p = testCh; char result = '\\0'; while (*p != result) &#123; list[*(p++)]++; &#125; p = testCh; while (*p != result) &#123; if (list[*p] == 1) &#123; result = *p; break; &#125; p++; &#125; printf(\"result:%c\",result);&#125; 5.查找两个子视图的共同父视图思路:分别记录两个子视图的所有父视图并保存到数组中，然后倒序寻找,直至找到第一个不一样的父视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)findCommonSuperViews:(UIView *)view1 view2:(UIView *)view2&#123; NSArray * superViews1 = [self findSuperViews:view1]; NSArray * superViews2 = [self findSuperViews:view2]; NSMutableArray * resultArray = [NSMutableArray array]; int i = 0; while (i &lt; MIN(superViews1.count, superViews2.count)) &#123; UIView *super1 = superViews1[superViews1.count - i - 1]; UIView *super2 = superViews2[superViews2.count - i - 1]; if (super1 == super2) &#123; [resultArray addObject:super1]; i++; &#125;else&#123; break; &#125; &#125; NSLog(@\"resultArray:%@\",resultArray); &#125;- (NSArray &lt;UIView *&gt;*)findSuperViews:(UIView *)view&#123; UIView * temp = view.superview; NSMutableArray * result = [NSMutableArray array]; while (temp) &#123; [result addObject:temp]; temp = temp.superview; &#125; return result;&#125; 6.求无序数组中的中位数中位数：当数组个数n为奇数时，为(n + 1)/2，即是最中间那个数字；当n为偶数时，为(n/2 + (n/2 + 1))/2,即是中间两个数字的平均数。 思路: 1.排序算法+中位数首先用冒泡排序、快速排序、堆排序、希尔排序等排序算法将所给数组排序，然后取出其中位数即可。2.利用快排思想","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"算法","slug":"算法","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"UI 为什么必须要在主线程更新","slug":"UI-为什么必须要在主线程更新","date":"2019-03-01T11:58:22.000Z","updated":"2020-07-28T05:41:08.579Z","comments":true,"path":"2019/03/01/UI-为什么必须要在主线程更新/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/03/01/UI-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0/","excerpt":"","text":"在iOS开发中，一直知道不能再子线程中更新UI，但是被面试官问到为什么不能再子线程中更新UI,却不知道了尴尬，这就是学习不探究原理的的毛病，要治。 UIKit 官方文档中有重点提示： Important Use UIKit classes only from your app’s main thread or main dispatch queue, unless otherwise indicated. This restriction particularly applies to classes derived from UIResponder or that involve manipulating your app’s user interface in any way. 意思就是只能在主线程或者主队列中使用UIKit类，特别适用于派生自UIPResponder的类，或者涉及到以任何方式操纵应用程序的用户界面。 我们探究背后的原因是什么？ UIKit并不是一个线程安全的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上同时更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。 UIKit非线程安全 在UIKit中，很多类中大部分的属性都被修饰为nonatomic，这意味着它们不能在多线程的环境下工作，而对于UIKit这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将nonatomic改成atomic或者是加锁解锁的操作，还涉及到很多的方面： 假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？ 假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。 如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？ 仔细思考，似乎能够多线程处理UI并没有给我们开发带来更多的便利，假如你代入了这些情景进行思考，你很容易得出一个结论： “我在一个串行队列对这些事件进行处理就可以了。” 苹果也是这样想的，所以UIKit的所有操作都要放到主线程串行执行。 在Thread-Safe Class Design一文提到： It’s a conscious design decision from Apple’s side to not have UIKit be thread-safe. Making it thread-safe wouldn’t buy you much in terms of performance; it would in fact make many things slower. And the fact that UIKit is tied to the main thread makes it very easy to write concurrent programs and use UIKit. All you have to do is make sure that calls into UIKit are always made on the main thread. 大意为把UIKit设计成线程安全并不会带来太多的便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。事实上并发编程也没有因为UIKit是线程不安全而变得困难，我们所需要做的只是要确保UI操作在主线程进行就可以了。 Runloop 与绘图循环 道理我们都懂，那这个究竟跟我们不能在后台线程操作UI有什么关系呢？ UIApplication在主线程所初始化的Runloop我们称为Main Runloop，它负责处理app存活期间的大部分事件，如用户交互等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够得到不断刷新也是因为Main Runloop在驱动着。 而每一个view的变化的修改并不是立刻变化，相反的会在当前run loop的结束的时候统一进行重绘，这样设计的目的是为了能够在一个runloop里面处理好所有需要变化的view，包括resize、hide、reposition等等，所有view的改变都能在同一时间生效，这样能够更高效的处理绘制，这个机制被称为绘图循环（View Drawing Cycle)。 理解iOS的渲染流程渲染系统框架 UIKit: 包含各种控件，负责对用户操作事件的响应，本身并不提供渲染的能力 Core Animation: 负责所有视图的绘制、显示与动画效果 OpenGL ES: 提供2D与3D渲染服务 Core Graphics: 提供2D渲染服务 Graphics Hardware: 指GPU 所以在iOS中，所有视图的现实与动画本质上是由 Core Animation 负责，而不是UIKit。 Core Animation Pipeline 流水线 Core Animation的绘制是通过Core Animation Pipeline实现，它以流水线的形式进行渲染，具体分为四个步骤： Commit Transaction: 可以细分为 - Layout: 构建视图布局如addSubview等操作 - Display: 重载drawRect:进行时图绘制，该步骤使用CPU与内存 - Prepare: 主要处理图像的解码与格式转换等操作 - Commit: 将Layer递归打包并发送到Render Server Render Server: 负责渲染工作，会解析上一步Commit Transaction中提交的信息并反序列化成渲染树（render tree)，随后根据layer的各种属性生成绘制指令，并在下一次VSync信号到来时调用OpenGL进行渲染。 GPU: GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。 Dispaly: 从缓冲区中取出画面，并输出到屏幕上。 知识补充：iOS的VSync与双缓冲机制VSync:VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。 这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。 双缓冲机制双缓冲机制是用于避免或减少画面闪烁的问题，在单缓冲的情况下，GPU输出了一帧画面，缓冲区就需要马上获取这个画面，并交给显示屏去显示，而这段时间GPU输出的画面就全都丢失了，因为没有缓冲区去承载这些画面，就会造成画面的闪烁。 而在双缓冲机制下有一个Back Frame Buffer和一个Front Frame Buffer，在GPU绘制完成后，它会将图像先保存到Back Frame Buffer中，操作完毕后，会调用一个交换函数，让绘制完成的Back Frame Buffer上的图像交换到Front Frame Buffer上。由于双缓冲利用了更多显存与CPU消耗时间，从而避免了画面的闪烁。 相信大家都会遇到过应用卡顿，卡顿的原因就是因为两帧的刷新时间间隔大于60帧每秒（约16.67ms），导致用户感觉点击或者滑动时，界面没有及时的响应。 前面提到Core Animation Pipeline是以流水线的形式工作的，在理想的状况下我们希望它能够在1/60s内完成图层树的准备工作并提交给渲染进程，而渲染进程在下一次VSync信号到来的时候提交给GPU进行渲染，并在1/60s内完成渲染，这样就不会产生任何的卡顿。 但是由于我们使用了我们的魔法UIKit，所以我们在许多后台线程进行了UI操作，在runloop的结尾准备进行渲染的时候，不同线程提交了不同的渲染信息，于是我们就拥有了更多的绘制事务，这个时候Core Animation Pipeline会不断将信息提交，让GPU进行渲染，由于绘制事件的不同步导致了GPU渲染的不同步，可能在上一帧是需要渲染一个label消失的画面，下一帧却又需要渲染这个label改变了文字，最终导致的是界面的不同步。 另一方面，在VSync和双缓冲机制我们可以看出渲染其实是一个十分消耗系统资源的操作（占用显存与CPU），所以可能会因为大量的事务和线程之间频繁的上下文切换导致了GPU无法处理，反而影响了性能，从而导致在1/60s中无法完成图层树的提交，导致了严重的卡顿。 Texture or ComponentKit 实现支持异步更新UI框架 AsyncDisplayKit（现命名为Texture） 是Facebook开源的一个用于保持iOS界面流畅的框架。 ComponentKit是Facebook开源的一个基于React思想的iOS原生UI开发框架。它通过函数式和声明的方式构建UI。 让我们撤销掉我们对UIKit施展的各种魔法，回到这个UI只能在主线程进行操作的世界吧。这两个框架其实并不是真正的在后台线程操作UI，而是用了更巧妙的方法将一些耗时的操作异步执行，从而绕开了UIKit只能在主线程操作的限制。 比如Texture创建了各类Node，在node中包含了UIView，而Node本身是线程安全的，所以允许在后台线程对Node进行修改，随后在第一次主线程访问View的时候它才会在内部生成对应的View，当node的属性发生改变的时候，他也不会马上进行修改，而是在适当的时机一次性的在主线程为内部的View进行设置。（有点类似于绘图循环） 而ComponentKit则是通过创建Component来描述UI，它也是一个线程安全的类。可以将Component认为是一个刻板，而UIView是刻板下的一张纸，渲染则是喷墨的过程。当我们生成了一个Component的时候，就等于生成了一个View的模版，在进行渲染的时候只要按照模版进行绘制就可以了。复杂的界面可以通过各种简单的Component来组成。（类似于Flutter的widget） 子线程中如何通知主线程（队列）更新UI方法，记录一下12345678910111213141516&#x2F;&#x2F;方法一[self performSelectorOnMainThread:@selector(updateImage:) withObject:data waitUntilDone:YES];&#x2F;&#x2F;方法二dispatch_async(dispatch_get_main_queue(), ^&#123;&#x2F;&#x2F;更新UI的代码，不用主线程中调用&#125;);&#x2F;&#x2F;方法三[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;NSLog(@&quot;线程2：%@&quot;,[NSThread currentThread]);&#125;];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"UI","slug":"UI","permalink":"https://bianchengme.gitee.io/bianchengme/tags/UI/"}]},{"title":"把Mac上好用的操作搬到Windows","slug":"把Mac上好用的操作搬到Windows","date":"2019-02-26T08:28:22.000Z","updated":"2020-07-28T05:41:08.629Z","comments":true,"path":"2019/02/26/把Mac上好用的操作搬到Windows/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2019/02/26/%E6%8A%8AMac%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%90%AC%E5%88%B0Windows/","excerpt":"","text":"Mac电脑上有几个笔记喜欢的操作，换到Windows上没有很不习惯：有空格预览、方向快捷键、Alfred软件等。 Windows没有这些功能，但是Windows上有丰富的第三方软件可以实现上面的功能甚至能更丰富。 QuickLook 点击空格快速预览文件； AutoHotKey 无所不能的快捷键； EveryThing 强大的文件搜索功能； Wox 开源软件类似Alfred,可以安装插件； Listary 类似Wox,收费软件用户体验更好，可以和Wox结合起来用； Snipaste 挺方便的截屏工具； Zeal 类似Dash的免费API工具，虽然比不上Dash好用；","categories":[{"name":"Windows","slug":"Windows","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Windows/"},{"name":"工具","slug":"工具","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Maven项目资源文件路径配置理解","slug":"mybatis-plus-xml-文件路径配置","date":"2018-10-31T12:12:30.000Z","updated":"2021-09-07T07:26:31.783Z","comments":true,"path":"2018/10/31/mybatis-plus-xml-文件路径配置/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2018/10/31/mybatis-plus-xml-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在Spring Boot中使用Mybatis Plus时遇到一个问题，在Mapper.java同目录下创建Mapper.xml文件，检查xml文件编写没有问题，application.yml文件中也配置了mapper-locations: classpath:mapper/*.xml,但是就是提示找不到xml文件。经过一番搜索，找到解决办法：在pom.xml 中 build 下添加： 12345678&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; 重新运行就发现可以正常运行项目，学习不能止于知其然，要做到知其所以然，为什么添加该配置项目就能找到xml文件。初步分析，build的时候java目录下的xml文件没有被打包，找到一段关于maven打包resource配置介绍： 1、介绍构建Maven项目的时候，如果没有进行特殊的配置，Maven会按照标准的目录结构查找和处理各种类型文件。 src/main/java和src/test/java这两个目录中的所有*.java文件会分别在comile和test-comiple阶段被编译，编译结果分别放到了target/classes和targe/test-classes目录中，但是这两个目录中的其他文件都会被忽略掉。 src/main/resouces和src/test/resources 这两个目录中的文件也会分别被复制到target/classes和target/test-classes目录中。 然后打包插件默认会把target/classes这个目录中的所有内容打入到jar包或者war包中。这个初步解释了上面的问题所在。 2、Maven项目的标准目录结构 src- main - java 源文件 - resources 资源文件 - filters 资源过滤文件 - config 配置文件 - scripts 脚本文件 - webapp web应用文件 - test - java 测试源文件 - resources 测试资源文件 - filters 测试资源过滤文件 - it 集成测试 - assembly assembly descriptors - site Site target- generated-sources - classes - generated-test-sources - test-classes - xxx.jar pom.xml LICENSE.txt NOTICE.txt README.txt 3、打包时资源文件的配置3.1、打包src/main/java目录下的xml一般情况下，我们用到的资源文件(各种xml，properites，xsd文件等)都放在src/main/resources下面，利用maven打包时，maven能把这些资源文件打包到相应的jar或者war里。 有时候，比如mybatis的mapper.xml文件，我们习惯把它和Mapper.java放一起，都在src/main/java下面，这样利用maven打包时，就需要修改pom.xml文件，来把mapper.xml文件一起打包进jar或者war里了，否则，这些文件不会被打包的。(maven认为src/main/java只是java的源代码路径) 下面通过一个简单的示例来说明: 项目结构如下所示，有两个UserMaper.xml文件，所在目录不同 默认情况下，在POM.XML目录下执行: mvn clean package 打包命令在target\\classes目录下不会把UserMapper.xml打包到下mapper目录下 而resources目录下的文件始终都会打包进jar包或war包 这个时候使用mybatis就会出一些问题，找不到UserMapper所对应的xml文件解决方法有如下几种: (1)配置POM.XML的resource把xml也打包到mapper目录下 12345678910111213141516171819202122232425&lt;build&gt; &lt;!-- 资源目录 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt; &lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt; &lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 其中**/*这样的写法，是为了保证各级子目录下的资源文件被打包。resources是可以看做是容器，这个容器里面可以放很多个像resource这样的配置。而directory就是配置文件所在的路径，includes从英文单词角度看，就是包含的意思，此时在执行命令，就会把xml也打包到mapper目录下了 Resources官方文档地址为:http://maven.apache.org/pom.html#Resources (2)maven-resources-plugin插件 为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。 默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。 12345678910111213141516171819202122232425262728293031&lt;!-- 此plugin可以用 利用此plugin，把源代码中的xml文件，打包到相应位置， 这里主要是为了打包Mybatis的mapper.xml文件 --&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-xmls&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!-- 过滤后缀为pem、pfx的证书文件 --&gt; &lt;nonFilteredFileExtensions&gt; &lt;nonFilteredFileExtension&gt;pem&lt;/nonFilteredFileExtension&gt; &lt;nonFilteredFileExtension&gt;pfx&lt;/nonFilteredFileExtension&gt; &lt;nonFilteredFileExtension&gt;p12&lt;/nonFilteredFileExtension&gt; &lt;/nonFilteredFileExtensions&gt; &lt;/configuration&gt;&lt;/plugin&gt; (3)build-helper-maven-plugin插件 123456789101112131415161718192021222324252627282930&lt;!-- 此plugin可以用 利用此plugin，把源代码中的xml文件， 打包到相应位置，这里主要是为了打包Mybatis的mapper.xml文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;add-resource&lt;/id&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;add-resource&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 3.2、src/main/resources目录下的xml等资源文件不被打包默认resources目录下的文件都会被打包，如果想resources目录下的xml文件不被打包，可通过如下配置: 12345678910111213&lt;!--过滤resource下的文件--&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*.properties&lt;/include&gt; &lt;!--打包properties文件--&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;*.xml&lt;/exclude&gt; &lt;!--过滤xml与yaml文件--&gt; &lt;exclude&gt;*.yaml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; 编译之后如下： 当然也可以通过插件来实现 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!-- 并把文件复制到target/conf目录下--&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/conf&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 指定不需要处理的资源 &lt;excludes&gt; &lt;exclude&gt;WEB-INF/*.*&lt;/exclude&gt; &lt;/excludes&gt; --&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.xml&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 实现的效果如下: 编译好之后，会在target目录下生成conf目录并且把resources目录下的所有文件都自动拷贝到target/conf/目录下。 4、补充Mybatis、MyBatisPlus xml文件配置：默认配置是去Mapper.class 目录下找同名的xml文件，按照上文介绍，如果xml文件和java文件在一起，或者在resources下同名包下，如果通过注解指定了扫描Mapper的包地址，则无需配置xml文件地址。 如果不一致：则需要要指定扫描所在包的位置： 1234567mybatis: mapper-locations: classpath*:mapper/*.xml,classpath*:mapper/other/*.xmlormybatis-plus: mapper-locations: classpath*:mapper/*.xml,classpath*:mapper/other/*.xml","categories":[{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/tags/java/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2018-03-30T04:15:14.000Z","updated":"2020-07-28T05:41:08.578Z","comments":true,"path":"2018/03/30/Markdown语法/","link":"","permalink":"https://bianchengme.gitee.io/bianchengme/2018/03/30/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"用Markdown写文章是程序员的最爱，那什么是Markdown？ MarkdownMarkdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。 你可以使用vim工具直接编辑md文件，也可以用记事本打开md文件编辑你的文章，也可以Markdown的编辑器编写，有很多在线的编辑器，还有不少客户端的编辑器，我是Mac系统，用的一个叫 Mou 的编辑器，还比较好使。Windows系统下，你可以自己找一下，应该也会有很好用的编辑器。 先简单介绍一下，Markdown的语法，具体怎么用，我相信大家一看例文就马上明白了。 斜体代码 1*斜体* 或者 _斜体_ 效果 斜体 粗体1**粗体** 或者 __粗体__ 效果 **粗体 标题可以在标题内容前输入特定数量的’#’来实现对应级别的HTML样式的标题。 1234567# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果 一级标题二级标题三级标题四级标题五级标题六级标题一级和二级标题还有一种写法： 12345一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 二级标题-------------------- 换行行尾输入两个或以上的空格，然后回车。或者行尾加上&lt;br&gt;。 引用 引用只需要在被引用的内容段落开头加上右尖括号&gt;即可。你可以选择只在开头加一个。也可以在每行前面都加一个，效果是一样的。 12345&gt; 这一整段的内容都会作为一个HTML的引用元素。引用元素是会自动优化排版的（reflowable，可回流）。你可以任意地将引用的内容包含进来，然后所有这些都会被解析成为单独一个引用元素。 效果 这一整段的内容都会作为一个HTML的引用元素。引用元素是会自动优化排版的（reflowable，可回流）。你可以任意地将引用的内容包含进来，然后所有这些都会被解析成为单独一个引用元素。 引用可以嵌套。如果要在一个引用里插入一个引用，可以用两个&gt;开头。依此类推，根据嵌套层次加相应数量的符号。 1234567&gt; 这是一个引用。这是第一行这是第二行。&gt;&gt; 这是一个嵌套的引用。这是第一行。这是第二行&gt; &gt; 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的&gt;可以有可以没有。 效果 这是一个引用。这是第一行 这是第二行。 这是一个嵌套的引用。这是第一行。 这是第二行 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的&gt;可以有可以没有。 链接链接可以在行内插入： 链接文字 1[Markdown](http:&#x2F;&#x2F;zh.wikipedia.com&#x2F;wiki&#x2F;Markdown) 效果 Markdown 水平分区线 要生成水平分区线，可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分区线。 12345* * *********- - ---------------------------------------- 效果 图片1![Foo](http:&#x2F;&#x2F;i.weather.com.cn&#x2F;images&#x2F;cn&#x2F;life&#x2F;2017&#x2F;04&#x2F;11&#x2F;11141533DF572FBBA092E37E6E843C656C318272.jpg) 效果 列表 123456789101112131415161718无序列表 使用 *，+，- 表示无序列表。 + 无序列表项 一 - 子无序列表 一 - 子无序列表 二 * 子无序列表 三 + 无序列表项 二 + 无序列表项 三有序列表 使用数字和点表示有序列表。 1. 有序列表项 一 1. 子有序列表项 一 2. 子有序列表项 二 2. 有序列表项 二 3. 有序列表项 三 效果 无序列表 使用 *，+，- 表示无序列表。 无序列表项 一 子无序列表 一 子无序列表 二 子无序列表 三 无序列表项 二 无序列表项 三 有序列表 使用数字和点表示有序列表。 有序列表项 一 子有序列表项 一 子有序列表项 二 有序列表项 二 有序列表项 三 代码行内代码快：代码用`包括效果 代码 代码块及代码高亮： 在4个`后加上语言类型，高亮显示代码 (4个`)(语言类型) 代码 (4个`) Markdown语法进阶字符转义Markdown中的转义字符为\\，可以转义的有： \\ 反斜杠` 反引号* 星号_ 下划线{} 大括号[] 中括号() 小括号# 井号+ 加号- 减号. 英文句号! 感叹号 删除线使用 ~~ 包括一段话表示删除线。 这是一段错误的文本。 表格单元格和表头 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行： 1234name | age---- | ---LearnShare | 12Mike | 32 效果 name age LearnShare 12 Mike 32 对齐在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： 123:--- 代表左对齐 :--: 代表居中对齐 ---: 代表右对齐 left center right aaaa bbbbbb ccccc a b c 插入其他内容 表格中可以插入其他 Markdown 中的行内标记： 1234| name | URL || ------------ | ------------------------------- || _Google_ | ![Google](https:&#x2F;&#x2F;www.google.com&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;1x&#x2F;googlelogo_color_272x92dp.png) || __YouTube__ | [YouTube](https:&#x2F;&#x2F;www.youtube.com&#x2F;) | 效果 name URL Google YouTube YouTube Html 标签 支持在 Markdown 语法中嵌套 Html 标签 选框使用带有 - [ ] 或 - [x] （未完成或已完成） 12- [ ] 未选- [x] 选中 效果 未选 选中","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Markdown/"}]}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://bianchengme.gitee.io/bianchengme/categories/JAVA/"},{"name":"JVM","slug":"JAVA/JVM","permalink":"https://bianchengme.gitee.io/bianchengme/categories/JAVA/JVM/"},{"name":"Docker","slug":"Docker","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Docker/"},{"name":"Nacos","slug":"Docker/Nacos","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Docker/Nacos/"},{"name":"mysql","slug":"mysql","permalink":"https://bianchengme.gitee.io/bianchengme/categories/mysql/"},{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/categories/java/"},{"name":"vue","slug":"vue","permalink":"https://bianchengme.gitee.io/bianchengme/categories/vue/"},{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/"},{"name":"git","slug":"git","permalink":"https://bianchengme.gitee.io/bianchengme/categories/git/"},{"name":"Xcode","slug":"iOS/Xcode","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/Xcode/"},{"name":"Objective-C","slug":"iOS/Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/categories/iOS/Objective-C/"},{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/categories/flutter/"},{"name":"Windows","slug":"Windows","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Windows/"},{"name":"Markdown","slug":"Markdown","permalink":"https://bianchengme.gitee.io/bianchengme/categories/Markdown/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://bianchengme.gitee.io/bianchengme/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://bianchengme.gitee.io/bianchengme/tags/JVM/"},{"name":"优化","slug":"优化","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E4%BC%98%E5%8C%96/"},{"name":"Docker","slug":"Docker","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Docker/"},{"name":"nacos","slug":"nacos","permalink":"https://bianchengme.gitee.io/bianchengme/tags/nacos/"},{"name":"部署","slug":"部署","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E9%83%A8%E7%BD%B2/"},{"name":"mysql","slug":"mysql","permalink":"https://bianchengme.gitee.io/bianchengme/tags/mysql/"},{"name":"java","slug":"java","permalink":"https://bianchengme.gitee.io/bianchengme/tags/java/"},{"name":"vue","slug":"vue","permalink":"https://bianchengme.gitee.io/bianchengme/tags/vue/"},{"name":"学习计划","slug":"学习计划","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"iOS","slug":"iOS","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS/"},{"name":"git","slug":"git","permalink":"https://bianchengme.gitee.io/bianchengme/tags/git/"},{"name":"Xcode","slug":"Xcode","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Xcode/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Objective-C/"},{"name":"面试","slug":"面试","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E9%9D%A2%E8%AF%95/"},{"name":"flutter","slug":"flutter","permalink":"https://bianchengme.gitee.io/bianchengme/tags/flutter/"},{"name":"BUG","slug":"BUG","permalink":"https://bianchengme.gitee.io/bianchengme/tags/BUG/"},{"name":"iOS真机运行","slug":"iOS真机运行","permalink":"https://bianchengme.gitee.io/bianchengme/tags/iOS%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C/"},{"name":"hook","slug":"hook","permalink":"https://bianchengme.gitee.io/bianchengme/tags/hook/"},{"name":"多线程","slug":"多线程","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Swift","slug":"Swift","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Swift/"},{"name":"UI","slug":"UI","permalink":"https://bianchengme.gitee.io/bianchengme/tags/UI/"},{"name":"RunTime","slug":"RunTime","permalink":"https://bianchengme.gitee.io/bianchengme/tags/RunTime/"},{"name":"网络","slug":"网络","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E7%AE%97%E6%B3%95/"},{"name":"Windows","slug":"Windows","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Windows/"},{"name":"工具","slug":"工具","permalink":"https://bianchengme.gitee.io/bianchengme/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"https://bianchengme.gitee.io/bianchengme/tags/Markdown/"}]}